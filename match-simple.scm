;; synthcode.com/scheme/match-simple.scm
;; with little change for error report

(define-syntax match
  (syntax-rules ()
    ((match expr (pat . body) ...)
     (match-gen-labels (quote (match expr (pat . body) ...))
                       expr start () (pat . body) ...))))

(define-syntax match-gen-labels
  (syntax-rules (=>)
    ((match-gen-labels info expr label ((k1 fk1 pat1 . body1) (k fk pat . body) ...))
     (let ((tmp expr))
       (letrec ((k (lambda () (match-one tmp pat (begin . body) (fk)))) ...
                (label (lambda ()
                         (format #t "~%")
                         (format #t "<match-fail!!!> >_<~%")
                         (format #t "<match-report-begin>~%")
                         (format #t ":matching-expression:~%")
                         (pretty-print tmp)
                         (format #t ":matching-body:~%")
                         (pretty-print info)
                         (format #t "<match-report-end>~%")
                         (error 'match "fali"))))
         (match-one tmp pat1 (begin . body1) (fk1)))))
    ((match-gen-labels info expr label (labels ...) (pat (=> fk) . body) . rest)
     (match-gen-labels info expr fk (labels ... (label fk pat . body)) . rest))
    ((match-gen-labels info expr label (labels ...) (pat . body) . rest)
     (match-gen-labels info expr fail (labels ... (label fail pat . body)) . rest))))

(define-syntax match-one
  (syntax-rules (__ ___ quote ? and or not)
    ((match-one var () sk fk)
     (if (null? var) sk fk))
    ((match-one var (quote a) sk fk)
     (if (equal? var 'a) sk fk))
    ((match-one var (and) sk fk) sk)
    ((match-one var (and a b ...) sk fk)
     (match-one var a (match-one var (and b ...) sk fk) fk))
    ((match-one var (or) sk fk) fk)
    ((match-one var (or a ...) sk fk)
     (let ((sk2 (lambda () sk)))
       (match-one var (not (and (not a) ...)) (sk2) fk)))
    ((match-one var (not a) sk fk)
     (match-one var a fk sk))
    ((match-one var (? pred a ...) sk fk)
     (if (pred var) (match-one var (and a ...) sk fk) fk))
    ((match-one var (a ___) sk fk)
     (match-extract-variables a (match-gen-ellipses var a sk fk) ()))
    ((match-one var (a) sk fk)
     (if (and (pair? var) (null? (cdr var)))
       (let ((tmp (car var)))
         (match-one tmp a sk fk))
       fk))
    ((match-one var (a . b) sk fk)
     (if (pair? var)
       (let ((tmp1 (car var)))
         (match-one tmp1 a (let ((tmp2 (cdr var))) (match-one tmp2 b sk fk)) fk))
       fk))
    ((match-one var #(a ...) sk fk)
     (if (vector? var)
       (let ((ls (vector->list var)))
         (match-one ls (a ...) sk fk))
       fk))
    ((match-one var __ sk fk) sk)
    ((match-one var x sk fk)
     (let-syntax ((sym?
                   (syntax-rules ()
                     ((sym? x) (let ((x var)) sk))
                     ((sym? y) (if (equal? var x) sk fk)))))
       (sym? abracadabra)))))

(define-syntax match-gen-ellipses
  (syntax-rules ()
    ((_ var a sk fk ((v v-ls) ...))
     (let loop ((ls var) (v-ls '()) ...)
       (cond ((null? ls)
              (let ((v (reverse v-ls)) ...) sk))
             ((pair? ls)
              (let ((x (car ls)))
                (match-one x a (loop (cdr ls) (cons v v-ls) ...) fk)))
             (else
              fk))))))

(define-syntax match-extract-variables
  (syntax-rules (__ ___ quote ? and or not)
    ((_ (a . b) k v)
     (match-extract-variables a (match-extract-variables-step b k v) ()))
    ((_ #(a ...) k v)
     (match-extract-variables (a ...) k v))
    ((_ a (k ...) (v ...))
     (let-syntax ((sym?
                   (syntax-rules ()
                     ((sym? a) (k ... (v ... (a a-ls))))
                     ((sym? b) (k ... (v ...))))))
       (sym? abracadabra)))))

(define-syntax match-extract-variables-step
  (syntax-rules ()
    ((_ a k (v ...) (v2 ...))
     (match-extract-variables a k (v ... v2 ...)))))
