#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+title: function compose, type cut

* intuitionistic [constructive] logic

  - to prove (P and Q)
    is to prove P and prove Q
    this is the same as classical logic

  - to prove (P or Q)
    is to prove P or prove Q
    while in classical logic
    you can prove (P or Q)
    without a proof of P
    and without a proof of Q

  - to prove (P -> Q)
    is to prove that
    if we have a proof of P
    then we can construct a proof of Q

  - to prove (not P)
    is to prove (P -> something-we-consider-wrong)
    something-we-consider-wrong like (0 = 1)
    (not (not P)) is weaker than P
    while in classical logic
    (not (not P)) is equal to P

  - to prove ((x : A) -> P(x))
    is to prove that
    for every (x : A) we can construct a proof of P(x)
    this is the same as classical logic

  - to prove (-> (x : A) P(x))
    is to construct a value of type A
    and construct a proof of P(x)
    the only way to prove something exist
    is to find such thing
    while in classical logic
    to prove something exist
    you do not need to find such thing

* >< a deduction system

  - >< why not cartesian closed category

* >< to compare with other deduction systems

  - sequent calculus with a little change to get an algebra of logic

* >< let us design a language to record deduction, a record of a deduction is a proof

* >< the language just designed can be viewed as a term-rewriting-system

* >< implementation of such a language

* ><

  - 所有的命題都是蘊含式
    其表示方式有兩種
    首先 箭頭
    (A -> B)
    其次 分數
    | A |
    |---|
    | B |
    對推演規則的表達可以用表格來寫
    比如
  - cut [product 的特殊形式]
    即同分子分母的消去
    | A | B | cut | A |
    |---+---+-----+---|
    | B | C |     | C |
  - curry & apply
    這裏與同形式的分數變換不同
    分子移下去以形成嵌套的分母時 還是做爲分子
    | A | curry |          |
    |---+-------+----------|
    | B | apply | (A -> B) |
  - imply 的語義
    如果有對 (-> A) 的構造
    那麼把這個構造轉化爲對 (-> B) 的構造的算法 就是對 (A -> B) 的構造
    imply [product 的特殊形式]
    |   | A | imply |   |
    |---+---+-------+---|
    | A | B |       | B |
  - conjunction-right [product 的特殊形式]
    |   |   | conjunction-right |     |
    |---+---+-------------------+-----|
    | A | B |                   | A B |
    in another way
    | C | D | conjunction-right | C D |
    |---+---+-------------------+-----|
    | A | B |                   | A B |
  - conjunction-left [drop]
    | A | conjunction-left | A B |
    |---+------------------+-----|
    |   |                  |     |
    or
    | B | conjunction-left | A B |
    |---+------------------+-----|
    |   |                  |     |
  - sum-left
    注意這裏的規則如何與一般的分式相加不同
    也就是說
    類型的運算規則
    只有 product 在形式上與分式的算數運算規則相同
    | A | B | sum-left | (A + B) |
    |---+---+----------+---------|
    |   |   |          |         |
    in another way
    | A | B | sum-left | (A + B) |
    |---+---+----------+---------|
    | C | D |          | (C + D) |
  - sum-right
    |   | sum-right |         |
    |---+-----------+---------|
    | A |           | (A + B) |
    or
    |   | sum-right |         |
    |---+-----------+---------|
    | B |           | (A + B) |
    即
    有對 (-> A) 的構造 就有對 (-> (A + B)) 的構造
    有對 (-> B) 的構造 就有對 (-> (A + B)) 的構造
    而古典的邏輯
    允許在證明 (-> (A + B)) 的時候根本不用構造 (-> A) 或 (-> A)
  - De Morgan's laws
    這裏涉及到 否定消除
    即 否定必須出現在最外層 並且用 conjunction 相連
    (否 (A 且 B))
    對應於
    | A B |
    |-----|
    |     |
    De Morgan's laws 沒法用 分式的推演規則表達
    如果能夠自由的使用 De Morgan's laws
    那麼
    命題演算中所有命題就能化爲可用分式表達的形式
    也就是說 分式的形式化能力是有限的
    把一個式子化爲 分式 已經是一次變化了
    這種解釋 否定 的方式是有問題的
    要知道
    一般人們定義 A 的 否定 的方式是 (A -> (0 = 1))
  - drop 之 存在 並不代表 能證明任何命題的否定
    因爲 drop 是個變換規則
    每個 變換規則 本身 也有類型 (... ->)
    但是
    drop 的類型對應的命題並不影響形式系統的一致性
  - pattern match
    match 與否
    決定了 product 的可行性
    一般的 product 是不交換的 考慮 cut 就知道了
    | A | (B + C) | product | A |
    |---+---------+---------+---|
    | B | D       |         | D |
    match 與否 被一個序關係決定
    在這個序關係中 (B + C) 高於 B
    所以
    就可以用 分子中的 (B + C)
    消除 分母中的 B

* note

  - 函數複合 與 類型切合 之間的區別是
    函數體爲則式的列表
    而類型爲單一的則式

  - cut 與分數的乘法太相似了
    是否能找到 sequent 在 cut 下的代數結構

    發現如果類型信息不減少的話
    也就是所有的 unify 都是嚴絲合縫的話
    那麼就有較好的代數性質
