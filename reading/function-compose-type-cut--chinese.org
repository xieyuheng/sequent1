#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+title: 函數複合 類型切合

* >< logic deduction

* >< the algebra of logic

  - 新語法的特點是
    1. 每個命題都帶有 ->
       可以理解爲分數線
    2. 消去否定詞
    3. 所有的 inference rule
       都用分數的運算規則來表示
  - 所有的命題都是蘊含式
    其表示方式有兩種
    首先 箭頭
    (A -> B)
    其次 分數
    | A |
    |---|
    | B |
    對推演規則的表達可以用表格來寫
    比如
  - cut [product 的特殊形式]
    即同分子分母的消去
    | A | B | cut | A |
    |---+---+-----+---|
    | B | C |     | C |
  - curry & apply
    這裏與同形式的分數變換不同
    分子移下去以形成嵌套的分母時 還是做爲分子
    | A | curry |          |
    |---+-------+----------|
    | B | apply | (A -> B) |
  - imply 的語義
    如果有對 (-> A) 的構造
    那麼把這個構造轉化爲對 (-> B) 的構造的算法 就是對 (A -> B) 的構造
    imply [product 的特殊形式]
    |   | A | imply |   |
    |---+---+-------+---|
    | A | B |       | B |
  - conjunction-right [product 的特殊形式]
    |   |   | conjunction-right |     |
    |---+---+-------------------+-----|
    | A | B |                   | A B |
    in another way
    | C | D | conjunction-right | C D |
    |---+---+-------------------+-----|
    | A | B |                   | A B |
  - conjunction-left [drop]
    | A | conjunction-left | A B |
    |---+------------------+-----|
    |   |                  |     |
    or
    | B | conjunction-left | A B |
    |---+------------------+-----|
    |   |                  |     |
  - sum-left
    注意這裏的規則如何與一般的分式相加不同
    也就是說
    類型的運算規則
    只有 product 在形式上與分式的算數運算規則相同
    | A | B | sum-left | (A + B) |
    |---+---+----------+---------|
    |   |   |          |         |
    in another way
    | A | B | sum-left | (A + B) |
    |---+---+----------+---------|
    | C | D |          | (C + D) |
  - sum-right
    |   | sum-right |         |
    |---+-----------+---------|
    | A |           | (A + B) |
    or
    |   | sum-right |         |
    |---+-----------+---------|
    | B |           | (A + B) |
    即
    有對 (-> A) 的構造 就有對 (-> (A + B)) 的構造
    有對 (-> B) 的構造 就有對 (-> (A + B)) 的構造
    而古典的邏輯
    允許在證明 (-> (A + B)) 的時候根本不用構造 (-> A) 或 (-> A)
  - De Morgan's laws
    這裏涉及到 否定消除
    即 否定必須出現在最外層 並且用 conjunction 相連
    (否 (A 且 B))
    對應於
    | A B |
    |-----|
    |     |
    De Morgan's laws 沒法用 分式的推演規則表達
    如果能夠自由的使用 De Morgan's laws
    那麼
    命題演算中所有命題就能化爲可用分式表達的形式
    也就是說 分式的形式化能力是有限的
    把一個式子化爲 分式 已經是一次變化了
    這種解釋 否定 的方式是有問題的
    要知道
    一般人們定義 A 的 否定 的方式是 (A -> (0 = 1))
  - drop 之 存在 並不代表 能證明任何命題的否定
    因爲 drop 是個變換規則
    每個 變換規則 本身 也有類型 (... ->)
    但是
    drop 的類型對應的命題並不影響形式系統的一致性
  - pattern match
    match 與否
    決定了 product 的可行性
    一般的 product 是不交換的 考慮 cut 就知道了
    | A | (B + C) | product | A |
    |---+---------+---------+---|
    | B | D       |         | D |
    match 與否 被一個序關係決定
    在這個序關係中 (B + C) 高於 B
    所以
    就可以用 分子中的 (B + C)
    消除 分母中的 B
  - 否定消去
    其動機在於
    在古典的命題演算中 (A -> B) 等價於 ((not A) or B)
    但是若如我所言 否定不能直接爲 or 所連
    那麼這裏的動機就失效了
    這種對等也許必定是不合適的
    (not (A -> B))
    (not ((not A) or B))
    ((not (not A)) and (not B))
    (A and (not B))
    ((not B) and A)
    而
    (A -> (not B))
    ((not A) or (not B))
    (not (A and B))
    ???
    (A B ->)

* >< 

* note 

  - 函數複合 與 類型切合 之間的區別是
    函數體爲則式的列表
    而類型爲單一的則式

  - 以命題證明爲中心
    作爲類型的則式 爲表達邏輯命題的方式
    作爲體的則式列表 爲記錄推演的語法

  - 以類型函數爲中心
    就是我們熟悉的意義

  - 在統一的框架下 總結各種風格的邏輯

  - cut 與分數的乘法太相似了
    是否能找到 sequent 在 cut 下的代數結構

    發現如果類型信息不減少的話
    也就是所有的 unify 都是嚴絲合縫的話
    那麼就有較好的代數性質

  - 真的需要 或 嗎
    hott 是如何處理 或 的

  - 如果有 或
    就可以用 deftype 來定義新的類型 模擬匿名的 或

  - 如果 defn = deftheorem
    那麼 deftype = ???
