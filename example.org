#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle example.scm
#+title: example code of sequent1

---------

- simple example code ([[https://github.com/xieyuheng/sequent1][source]])

---------

* natural

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (~ factorial (natural -> natural)
      (zero -> zero succ)
      (:n succ -> :n factorial :n succ mul))

   (app (->
         zero succ
         zero succ succ
         add))

   (app (->
         zero succ succ
         zero succ succ
         mul))

   (app (->
         zero succ succ succ
         factorial)))
  #+end_src

* add/commute by richly-defined add

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (zero :m -> :m)
      (:m succ :n succ -> :m :n add succ succ))

   (+ eq ({:t : type} :t :t -> type)
      refl ({:t : type} {:d : :t} -> :d :d eq))

   (~ eq/test
      (-> zero zero add zero zero add eq)
      (-> refl))

   (~ add/commute ((:m :n : natural) -> :m :n add :n :m add eq)
      (:m zero -> refl)
      (:m :n succ -> refl)))
  #+end_src

* stack processing

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ drop (:t ->)
      (:d ->))

   (~ dup (:t -> :t :t)
      (:d -> :d :d))

   (~ over (:t1 :t2 -> :t1 :t2 :t1)
      (:d1 :d2 -> :d1 :d2 :d1))

   (~ tuck (:t1 :t2 -> :t2 :t1 :t2)
      (:d1 :d2 -> :d2 :d1 :d2))

   (~ swap (:t1 :t2 -> :t2 :t1)
      (:d1 :d2 -> :d2 :d1))

   (app (-> zero
            zero succ
            swap
            drop
            dup)))
  #+end_src

* list

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (+ list ({:t : type} :t -> type)
      null (-> :t list)
      cons (:t list :t -> :t list))

   (~ append (:t list :t list -> :t list)
      (:l null -> :l)
      (:l :r :e cons -> :l :r append :e cons))

   (app (->
         null
         zero cons
         null
         zero cons
         append))

   (app (->
         null
         zero cons
         zero cons
         null
         zero cons
         zero cons
         append)))
  #+end_src

* ><><>< list map

  - cover-check of map/has-length is wrong

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (+ list ({:t : type} :t -> type)
      null (-> :t list)
      cons (:t list :t -> :t list))

   (~ append (:t list :t list -> :t list)
      (:l null -> :l)
      (:l :r :e cons -> :l :r append :e cons))

   (~ map (:t1 list (:t1 -> :t2) -> :t2 list)
      (null :f -> null)
      (:l :e cons :f -> :l :f map :e :f apply cons))

   (app (->
         null
         zero cons
         zero cons
         zero cons
         null
         zero cons
         zero cons
         zero cons
         append
         (zero -> zero succ)
         map))

   (app (->
         null
         zero cons
         zero cons
         (lambda (natural -> natural)
           (zero -> zero succ))
         map))

   (+ has-length ({:t : type} :t list natural -> type)
      null/has-length (-> null zero has-length)
      cons/has-length (:l :n has-length -> :l :a cons :n succ has-length))

   (~ map/has-length (:l :n has-length -> :l :f map :n has-length)
      (null/has-length -> null/has-length)
      (:h cons/has-length -> :h map/has-length cons/has-length)))
  #+end_src

* vector

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   ;; ;; this can not be used to prove append
   ;; (~ add (natural natural -> natural)
   ;;    (:m zero -> :m)
   ;;    (zero :m -> :m)
   ;;    (:m succ :n succ -> :m :n add succ succ))

   ;; ;; this can be used to prove append
   ;; (~ add (natural natural -> natural)
   ;;    (:m zero -> :m)
   ;;    (zero :m -> :m)
   ;;    (:m succ :n succ -> :m :n add succ succ)
   ;;    (:m :n succ -> :m :n add succ)
   ;;    (:m succ :n -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (+ vector ({:t : type} natural :t -> type)
      null (-> zero :t vector)
      cons (:n :t vector :t -> :n succ :t vector))

   (~ append (:m :t vector :n :t vector -> :m :n add :t vector)
      (:l null -> :l)
      (:l :r :e cons -> :l :r append :e cons))

   (app (->
         null
         zero cons
         zero cons
         zero cons
         null
         zero cons
         zero cons
         zero cons
         append)))
  #+end_src

* vector map

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (+ vector ({:t : type} natural :t -> type)
      null (-> zero :t vector)
      cons (:n :t vector :t -> :n succ :t vector))

   (~ append (:m :t vector :n :t vector -> :m :n add :t vector)
      (:l null -> :l)
      (:l :r :e cons -> :l :r append :e cons))

   (~ map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      (null :f -> null)
      (:l :e cons :f -> :l :f map :e :f apply cons))

   (app (->
         null
         zero cons
         zero cons
         zero cons
         null
         zero cons
         zero cons
         zero cons
         append
         (zero -> zero succ)
         map))

   (app (->
         null
         zero cons
         zero cons
         (lambda (natural -> natural)
           (zero -> zero succ))
         map)))
  #+end_src

* >< associative of add

  #+begin_src scheme :tangle no
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (+ eq ({:t : type} :t :t -> type)
      refl ({:t : type} {:d : :t} -> :d :d eq))

   (~ eq/test1
      (-> :z zero succ succ eq
          :y :z eq
          :y zero succ zero succ add eq)
      (-> refl refl refl))

   (~ cong
      ({:t1 :t2 : type} {:x :y : :t1}
       :x :y eq (:f : (:t1 -> :t2)) ->
       :x :f apply :y :f apply eq)
      (refl :f -> refl))

   (~ associative
      ((:x :y :z : natural) ->
       :z :x :y add add
       :z :y add :x add eq)
      (:x :y zero -> refl)
      (:x :y :z succ -> :x :y :z associative (:n -> :n succ) cong)
      ))
  #+end_src

* natural-induction

  #+begin_src scheme
  (eva

   (+ natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

   (~ add (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n add succ))

   (~ mul (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n mul :m add))

   (~ natural-induction
      ((:p : (natural -> type))
       zero :p apply
       ((:k : natural) :k :p apply -> :k succ :p apply)
       (:x : natural) -> :x :p apply)
      (:p :p-z :p-s zero -> :p-z)
      (:p :p-z :p-s :k succ ->
          :k
          :p :p-z :p-s :k natural-induction
          :p-s apply)))
  #+end_src
