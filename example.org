#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle example.scm
#+title: example code of sequent1

---------

- simple example code ([[https://github.com/xieyuheng/sequent1][source]])

---------

* >< from scheme

*** note

    - these examples are learned from [[http://www.ccs.neu.edu/home/matthias/BTLS/][the little schemer]]

*** ><

* from agda

*** note

    - these examples are learned from [[http://www.cs.cmu.edu/~drl/teaching/oplss13/][a course about agda]] at [[https://www.cs.uoregon.edu/research/summerschool/summer13/curriculum.html][OPLSS 2013]]

*** natural

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (~ factorial (natural -> natural)
        (zero -> zero succ)
        (:n succ -> :n factorial :n succ mul))

     (app (->
           zero succ
           zero succ succ
           add))

     (app (->
           zero succ succ
           zero succ succ
           mul))

     (app (->
           zero succ succ succ
           factorial)))
    #+end_src

*** list

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (+ list ({:t : type} :t -> type)
        null (-> :t list)
        cons (:t list :t -> :t list))

     (~ append (:t list :t list -> :t list)
        (:l null -> :l)
        (:l :r :e cons -> :l :r append :e cons))

     (app (->
           null
           zero cons
           null
           zero cons
           append))

     (app (->
           null
           zero cons
           zero cons
           null
           zero cons
           zero cons
           append)))
    #+end_src

*** list map

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (+ list ({:t : type} :t -> type)
        null (-> :t list)
        cons (:t list :t -> :t list))

     (~ append (:t list :t list -> :t list)
        (:l null -> :l)
        (:l :r :e cons -> :l :r append :e cons))

     (~ map (:t1 list (:t1 -> :t2) -> :t2 list)
        (null :f -> null)
        (:l :e cons :f -> :l :f map :e :f apply cons))

     (app (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append
           (zero -> zero succ)
           map))

     (app (->
           null
           zero cons
           zero cons
           (lambda (natural -> natural)
             (zero -> zero succ))
           map))

     (+ has-length ({:t : type} :t list natural -> type)
        null/has-length (-> null zero has-length)
        cons/has-length (:l :n has-length -> :l :a cons :n succ has-length))

     (~ map/has-length (:l :n has-length -> :l :f map :n has-length)
        (null/has-length -> null/has-length)
        (:h cons/has-length -> :h map/has-length cons/has-length)))
    #+end_src

*** vector

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (+ vector ({:t : type} natural :t -> type)
        null (-> zero :t vector)
        cons (:n :t vector :t -> :n succ :t vector))

     (~ append (:m :t vector :n :t vector -> :m :n add :t vector)
        (:l null -> :l)
        (:l :r :e cons -> :l :r append :e cons))

     (app (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src

*** vector map

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (+ vector ({:t : type} natural :t -> type)
        null (-> zero :t vector)
        cons (:n :t vector :t -> :n succ :t vector))

     (~ append (:m :t vector :n :t vector -> :m :n add :t vector)
        (:l null -> :l)
        (:l :r :e cons -> :l :r append :e cons))

     (~ map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
        (null :f -> null)
        (:l :e cons :f -> :l :f map :e :f apply cons))

     (app (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append
           (zero -> zero succ)
           map))

     (app (->
           null
           zero cons
           zero cons
           (lambda (natural -> natural)
             (zero -> zero succ))
           map)))
    #+end_src

*** >< associative of add

    #+begin_src scheme :tangle no
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ add (natural natural -> natural)
        (:m zero -> :m)
        (:m :n succ -> :m :n add succ))

     (~ mul (natural natural -> natural)
        (:m zero -> zero)
        (:m :n succ -> :m :n mul :m add))

     (+ eq ({:t : type} :t :t -> type)
        refl ({:t : type} {:d : :t} -> :d :d eq))

     (~ cong
        ({:t1 :t2 : type} {:x :y : :t1}
         :x :y eq (:f : (:t1 -> :t2)) ->
         :x :f apply :y :f apply eq)
        (refl :f -> refl))

     (~ associative
        ((:x :y :z : natural) ->
         :x :y add :z add
         :x :y :z add add eq)
        (:x :y zero -> refl)
        (:x :y :z succ -> :x :y :z associative (:n -> :n succ) cong)))
    #+end_src

* from forth

*** swap

    #+begin_src scheme
    (eva

     (+ natural (-> type)
        zero (-> natural)
        succ (natural -> natural))

     (~ swap (:t1 :t2 -> :t2 :t1)
        (:d1 :d2 -> :d2 :d1))

     (app (-> zero
              zero succ
              swap)))
    #+end_src

* >< from joy
