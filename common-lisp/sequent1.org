+ sequent calculus as dependent type system of functional language

+ a prototype interpreter

+ XIE Yuheng created

#+PROPERTY: tangle sequent1.lisp

* todo

  - improve the interface to get rid of 'unify-point and '(commit-point)

  - success should track the path into nested ???
    when fail path can be used in report


  - refactoring
    those labels
    those local helper functions

  - proper tail-call

* note

*** formal-form

    - formal-arrow = (formal-cedent formal-cedent)
    - formal-cedent = (formal-form ...)
    - formal-form =
      - ('v formal-var)
      - ('n formal-name)
      - ('a formal-arrow)
      - ('b formal-bind)
    - formal-var = (symbol level)
    - formal-name = symbol
    - formal-bind = ((formal-var ...) formal-cedent leave?)

*** form

    - arrow = (cedent cedent)
    - cedent = (form ...)
    - form =
      - ('var var)
      - ('name name)
      - ('arrow arrow)
      - ('bind bind)
    - var = (id level)
    - name = symbol
    - bind = ((var ...) cedent leave?)
    - id = #(symbol ls)

*** env

    - env = (ds bs ns)
    - ds = (data ...)
    - bs = ((id . ls) ...)
      - ls = ((level . data) ...)
    - ns = ((name . store) ...)

*** data

    - data =
      - ('var var)
      - ('arrow arrow)
      - ('cons (name (data ...)))
      - ('trunk ((arrow ...) (data ...)))

*** store

    - store =
      - ('function function)
      - ('type-constructor type-constructor)
      - ('data-constructor data-constructor)
    - function = (formal-arrow arity (formal-arrow ...))
    - type-constructor = (formal-arrow arity (name ...))
    - data-constructor = (formal-arrow arity name)
    - arity = number

*** top

    - top =
      - ('dt type-definition)
      - ('df function-definition)
      - ('ap formal-arrow)
    - type-definition =
      ((formal-name formal-arrow) ((formal-name formal-arrow) ...))
    - function-definition =
      ((formal-name formal-arrow) (formal-arrow ...))

* helper

*** match

***** note

      - synopsis
        (match expression
          (pattern  action+)
          ...)

        or
        (match expression
          pattern => expression
          pattern => expression
          ...)

        pattern
        -   constant                ;egs  1, #\x, #c(1.0 1.1)
        -   symbol                  ;matches anything
        -   'anything               ;must be EQUAL
        -   (pattern = pattern)     ;both patterns must match
        -   (#'function pattern)    ;predicate test
        -   (pattern . pattern)     ;cons cell

      - example
        (match item
            (('if e1 e2 e3) 'if-then-else)                          ;(1)
            ((#'oddp k)     'an-odd-integer)                        ;(2)
            (((#'treep tree) = (hd . tl))   'something-else)        ;(3)
            (other          'anything-else))                        ;(4)

      - note
        - Each pattern is tested in turn.  The first match is taken.
        - If no pattern matches, an error is signalled.
        - Constant patterns (things X for which (CONSTANTP X) is true, i.e.
          numbers, strings, characters, etc.) match things which are EQUAL.
        - Quoted patterns (which are CONSTANTP) are constants.
        - Symbols match anything. The symbol is bound to the matched item
          for the execution of the actions.
          For example, (match '(1 2 3) (1 . X) => X)
          returns (2 3) because X is bound to the cdr of the candidate.
        - The two pattern match (p1 = p2) can be used to name parts
          of the matched structure.  For example, (ALL = (HD . TL))
          matches a cons cell. ALL is bound to the cons cell, HD to its car
          and TL to its tail.
        - A predicate test applies the predicate to the item being matched.
          If the predicate returns NIL then the match fails.
          If it returns truth, then the nested pattern is matched.  This is
          often just a symbol like K in the example.
        - Care should be taken with the domain values for predicate matches.
          If, in the above eg, item is not an integer, an error would occur
          during the test.  A safer pattern would be
          (#'integerp (#'oddp k))
          This would only test for oddness of the item was an integer.
        - A single symbol will match anything so it can be used as a default
          case, like OTHER above.

***** match

      #+begin_src lisp
      (defmacro match (expression &rest patterns)
        (let* ((do-let (not (atom expression)))
               (key    (if do-let (gensym) expression))
               (cbody  (expand-select-patterns key patterns))
               (cform  `(cond . ,cbody)))
          (if do-let
              `(let ((,key ,expression)) ,cform)
              cform)))

      (defun expand-select-patterns (key patterns)
        (if (eq (second patterns) '=>)
            (expand-select-patterns-style-2 key patterns)
            (expand-select-patterns-style-1 key patterns)))

      (defun expand-select-patterns-style-1 (key patterns)
        (if (null patterns)
            `((T (error "Case select pattern match failure on ~S" ,key)))
            (let ((pattern  (caar patterns))
                  (actions  (cdar patterns))
                  (rest     (cdr patterns)) )
              (let  ((test       (compile-select-test key pattern))
                     (bindings   (compile-select-bindings key pattern actions)))
                `(,(if bindings  `(,test (let ,bindings . ,actions))
                       `(,test . ,actions))
                   . ,(if (eq test t)
                          nil
                          (expand-select-patterns-style-1 key rest)))))))

      (defun expand-select-patterns-style-2 (key patterns)
        (if (null patterns)
            `((T (error "Case select pattern match failure on ~S" ,key)))
            (let ((pattern  (first patterns))
                  (arrow    (if (or (< (length patterns) 3)
                                    (not (eq (second patterns) '=>)))
                                (error "Illegal patterns: ~S" patterns)))
                  (actions  (list (third patterns)))
                  (rest     (cdddr patterns)))
              (let  ((test       (compile-select-test key pattern))
                     (bindings   (compile-select-bindings key pattern actions)))
                `(,(if bindings  `(,test (let ,bindings . ,actions))
                       `(,test . ,actions))
                   . ,(if (eq test t)
                          nil
                          (expand-select-patterns-style-2 key rest)))))))


      (defun compile-select-test (key pattern)
        (let  ((tests (remove-if
                       #'(lambda (item) (eq item t))
                       (compile-select-tests key pattern))))
          (cond
            ;; note AND does this anyway, but this allows us to tell if
            ;; the pattern will always match.
            ((null tests)           t)
            ((= (length tests) 1)   (car tests))
            (T                      `(and . ,tests)))))


      (defun compile-select-tests (key pattern)
        (cond ((constantp pattern)
               `((,(cond ((numberp pattern) 'eql)
                         ((symbolp pattern) 'eq)
                         (T                'equal))
                   ,key ,pattern)))

              ((symbolp pattern) '(T))
              ((select-double-match? pattern)
               (append
                (compile-select-tests key (first pattern))
                (compile-select-tests key (third pattern))))
              ((select-predicate? pattern)
               (append
                `((,(second (first pattern)) ,key))
                (compile-select-tests key (second pattern))))
              ((consp pattern)
               (append
                `((consp ,key))
                (compile-select-tests (!cs-car key) (car
                                                     pattern))
                (compile-select-tests (!cs-cdr key) (cdr
                                                     pattern))))
              ('T         (error "Illegal select pattern: ~S" pattern))))

      (defun compile-select-bindings (key pattern action)
        (cond ((constantp pattern) '())
              ((symbolp pattern)
               (if (select!-in-tree pattern action) `((,pattern ,key))
                   '()))
              ((select-double-match? pattern)
               (append
                (compile-select-bindings key (first pattern) action)
                (compile-select-bindings key (third pattern)
                                         action)))
              ((select-predicate? pattern)
               (compile-select-bindings key (second pattern)
                                        action))
              ((consp pattern)
               (append
                (compile-select-bindings (!cs-car key) (car pattern)
                                         action)
                (compile-select-bindings (!cs-cdr key) (cdr pattern)
                                         action)))))

      (defun select!-in-tree (atom tree)
        (or (eq atom tree)
            (if (consp tree)
                (or (select!-in-tree atom (car tree))
                    (select!-in-tree atom (cdr tree))))))

      (defun select-double-match? (pattern)
        ;;  (<pattern> = <pattern>)
        (and (consp pattern) (consp (cdr pattern)) (consp (cddr pattern))
             (null (cdddr pattern))
             (eq (second pattern) '=)))

      (defun select-predicate? (pattern)
        ;; ((function <f>) <pattern>)
        (and    (consp pattern)
                (consp (cdr pattern))
                (null (cddr pattern))
                (consp (first pattern))
                (consp (cdr (first pattern)))
                (null (cddr (first pattern)))
                (eq (caar pattern) 'function)))

      (defun !cs-car (exp)
        (!cs-car/cdr
         'car exp
         '((car . caar)    (cdr . cadr)    (caar . caaar)  (cadr . caadr)
           (cdar . cadar)  (cddr . caddr)
           (caaar . caaaar)    (caadr . caaadr)    (cadar . caadar)
           (caddr . caaddr)    (cdaar . cadaar)    (cdadr . cadadr)
           (cddar . caddar)    (cdddr . cadddr))))

      (defun !cs-cdr (exp)
        (!cs-car/cdr
         'cdr exp
         '((car . cdar)    (cdr . cddr)    (caar . cdaar)  (cadr . cdadr)
           (cdar . cddar)  (cddr . cdddr)
           (caaar . cdaaar)    (caadr . cdaadr)    (cadar . cdadar)
           (caddr . cdaddr)    (cdaar . cddaar)    (cdadr . cddadr)
           (cddar . cdddar)    (cdddr . cddddr))))

      (defun !cs-car/cdr (op exp table)
        (if (and (consp exp) (= (length exp) 2))
            (let ((replacement  (assoc (car exp) table)))
              (if replacement
                  `(,(cdr replacement) ,(second exp))
                  `(,op ,exp)))
            `(,op ,exp)))

      ;; (setf c1 '(match x (a 1) (b 2 3 4)))
      ;; (setf c2 '(match (car y)
      ;;            (1 (print 100) 101) (2 200) ("hello" 5) (:x 20) (else (1+
      ;;                                                                   else))))
      ;; (setf c3 '(match (caddr y)
      ;;            ((all = (x y)) (list x y all))
      ;;            ((a '= b)      (list 'assign a b))
      ;;            ((#'oddp k)     (1+ k))))

      ;;
      ;;  IN macro
      ;;
      ;;  (IN exp LET pat1 = exp1
      ;;              pat2 = exp2
      ;;              ...)
      ;;
      ;;  (IN exp LET* pat1 = exp1
      ;;               pat2 = exp2
      ;;               ...)
      ;;

      (defmacro in (&rest form)
        (match form
          (exp 'let . pats) =>
          (let* ((exps   (select-in-let-parts pats 'exp))
                 (pats   (select-in-let-parts pats 'pat))
                 (vars   (mapcar #'(lambda (x) (gensym)) exps)))
            `(let ,(mapcar #'list vars exps)
               ,(reduce
                 #'(lambda (var-pat subselection)
                     (let ((var  (first var-pat))
                           (pat  (second var-pat)))
                       `(match ,var
                          ,pat => ,subselection
                          else => (error "IN-LET type error: ~S
      doesnt match ~S" ,var ',pat))))
                 (mapcar #'list vars pats)
                 :from-end t
                 :initial-value exp)))
          (exp 'let*)         => exp
          (exp 'let* pat '= patexp . pats)  =>
          (let ((var (gensym)))
            `(let ((,var ,patexp))
               (match ,var
                 ,pat => (in ,exp let* . ,pats)
                 else => (error "IN-LET type error: ~S doesnt match
      ~S" ,var ',pat))))
          else                =>
          (error "Illegal IN form ~S" form)))

      (defun select-in-let-parts (pats part)
        (match pats
          nil => nil
          (pat '= exp . rest) =>
          (cons (match part
                  'exp => exp
                  'pat => pat)
                (select-in-let-parts rest part))
          other =>
          (error "Illegal LET form(s): ~S" pats)))

      ;; (setf eg1 '(in (list h1 h2 t1 t2)
      ;;             let
      ;;             (h1 . t1) = (foo x)
      ;;             (h2 . t2) = (bar y)))
      #+end_src

***** test

      #+begin_src lisp :tangle no
      (defun fact (n)
        (match n
          '0 => 1
          n => (* n (fact (1- n)))))

      (fact 10)

      (defun eval-expr (x)
        (match x
          ('add x y) => (+ (eval-expr x) (eval-expr y))
          ('sub x y) => (- (eval-expr x) (eval-expr y))
          ('mul x y) => (* (eval-expr x) (eval-expr y))
          ('div x y) => (/ (eval-expr x) (eval-expr y))
          v => v))

      (eval-expr '(add 1 2))
      (eval-expr '(add 1 (add 2 3)))

      (defun my-append (a b)
        (match a
          () => b
          (hd . tl) => (cons hd (my-append tl b))))

      (my-append '(1 2 3) '(4 5 6))
      #+end_src

*** cat & orz

***** cat

      #+begin_src lisp
      ;; (cat (:to *standard-output*)
      ;;   ("~A" 123)
      ;;   ("~A" 456))
      ;; ==>
      ;; (concatenate
      ;;  'string
      ;;  (format *standard-output* "~A" 123)
      ;;  (format *standard-output* "~A" 456))

      ;; (defmacro cat
      ;;     ((&key (to nil))
      ;;      &body form/list-of-list)
      ;;   (let* ((form/list-of-list/2
      ;;           (mapcar (lambda (list) (append `(format ,to) list))
      ;;                   form/list-of-list))
      ;;          (form/final (append '(concatenate (quote string))
      ;;                              form/list-of-list/2)))
      ;;     form/final))

      (defmacro cat
          ((&key (to nil)
                 (trim '())
                 prefix
                 postfix
                 letter)
           &body form/list-of-list)
        (let* ((form/list-of-list/2
                (apply (function append)
                       (mapcar (lambda (list)
                                 (list prefix
                                       (list 'string-trim trim
                                             (append '(format nil) list))
                                       postfix))
                               form/list-of-list)))
               (form/list-of-list/3
                (append '(concatenate (quote string))
                        form/list-of-list/2))
               (form/final
                (cond ((equal letter :big)
                       (list 'string-upcase form/list-of-list/3))
                      ((equal letter :small)
                       (list 'string-downcase form/list-of-list/3))
                      ((equal letter nil)
                       form/list-of-list/3)
                      (:else
                       (error "the argument :letter of (cat) must be :big or :small or nil")))))
          `(let ((string-for-return ,form/final))
             (format ,to "~A" string-for-return)
             string-for-return)))

      ;; (cat (:to *standard-output*
      ;;           :trim '(#\Space)
      ;;           :prefix "* "
      ;;           :postfix (cat () ("~%")))
      ;;   ("~A" "      123   ")
      ;;   ("~A" "   456   "))
      #+end_src

***** orz

      #+begin_src lisp
      (defmacro orz
          ((&key (to nil)
                 (trim '())
                 prefix
                 postfix
                 letter)
           &body form/list-of-list)
        `(error (cat (:to ,to
                          :trim ,trim
                          :prefix ,prefix
                          :postfix ,postfix
                          :letter ,letter)
                  ,@form/list-of-list)))
      #+end_src

***** test

      #+begin_src lisp
      (cat ()
        ("~A" 123)
        ("~A" 456))
      ;; ==> "123456"

      ;; (cat ()
      ;;   ("~A" 123)
      ;;   ("~A" 456))

      ;; (cat (:to *standard-output*)
      ;;   ("~%")
      ;;   ("~A~%" 123)
      ;;   ("~A~%" 456))

      ;; (let ((x 123))
      ;;   (cat (:to *standard-output*)
      ;;     ("~A~%" x)))
      #+end_src

*** list

    #+begin_src lisp
    (defun left-of (s l)
      (cond ((eq s (car l)) '())
            (:else (cons (car l) (left-of s (cdr l))))))

    (defun right-of (s l)
      (cond ((eq s (car l)) (cdr l))
            (:else (right-of s (cdr l)))))
    #+end_src

*** string

    #+begin_src lisp
    (defun find-char (char string &key (curser 0))
      (if (>= curser (length string))
          nil
          (let ((char0 (subseq string curser (+ 1 curser))))
            (if (equal char char0)
                curser
                (find-char char string :curser (+ 1 curser))))))
    #+end_src

* parse

*** parse/arrow

    #+begin_src lisp
    (defun parse/arrow (s)
      ;; sexp-arrow -> formal-arrow
      (list (parse/cedent 0 (left-of '-> s))
            (parse/cedent 0 (right-of '-> s))))
    #+end_src

*** parse/cedent

    #+begin_src lisp
    (defun parse/cedent (default-level s)
      ;; default-level, sexp-cedent -> formal-cedent
      (match s
        () => ()
        (h . r) => (cons (parse/dispatch default-level h)
                         (parse/cedent default-level r))))
    #+end_src

*** parse/dispatch

    #+begin_src lisp
    (defun parse/dispatch (default-level v)
      ;; default-level, sexp-form -> formal-form
      (flet ((var? (v) (keywordp v))
             (name? (v) (and (symbolp v) (not (keywordp v))))
             (arrow? (v) (and (listp v) (member '-> v)))
             (im-bind? (v) (and (listp v) (member :> v)))
             (ex-bind? (v) (and (listp v) (member '@ v))))
        (cond ((var? v) (list 'v (parse/var default-level v)))
              ((name? v) (list 'n v))
              ((arrow? v) (list 'a (parse/arrow v)))
              ((im-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of :> v))
                                        (parse/cedent 0 (right-of :> v))
                                        nil)))
              ((ex-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of '@ v))
                                        (parse/cedent 0 (right-of '@ v))
                                        :true))))))
    #+end_src

*** parse/var

    #+begin_src lisp
    (defun parse/var (default-level v)
      ;; default-level, keyword -> formal-var
      (let* ((string (symbol-name v))
             (cursor (find-char "^" string)))
        (if cursor
            (list (intern (subseq string 0 cursor) :keyword)
                  (parse-integer string
                                 :start (+ 1 cursor)
                                 :junk-allowed t
                                 :radix 10))
            (list v default-level))))
    #+end_src

*** test

    #+begin_src lisp
    (assert
     (equal

      (list
       (parse/arrow '(natural natural -> natural))
       (parse/arrow '(natural natural -> (natural natural -> natural) natural))
       (parse/arrow '(:m zero -> :m))
       (parse/arrow '(:m :n succ -> :m :n recur succ))
       (parse/arrow '((:t :> type) :t -> type))
       (parse/arrow '((:t @ type) :t -> type))
       (parse/arrow '((:t^2 :> type) :t -> type))
       (parse/arrow '((:t1 :t2^2 :t3^0 :> j k) :t -> type))
       (parse/arrow '((:t^2 @ type) :t -> type)))

      '((((n natural) (n natural)) ((n natural)))
        (((n natural) (n natural)) ((a (((n natural) (n natural)) ((n natural)))) (n natural)))
        (((v (:m 0)) (n zero)) ((v (:m 0))))
        (((v (:m 0)) (v (:n 0)) (n succ)) ((v (:m 0)) (v (:n 0)) (n recur) (n succ)))
        (((b (((v (:t 1))) ((n type)) nil)) (v (:t 0))) ((n type)))
        (((b (((v (:t 1))) ((n type)) :true)) (v (:t 0))) ((n type)))
        (((b (((v (:t 2))) ((n type)) nil)) (v (:t 0))) ((n type)))
        (((b (((v (:t1 1)) (v (:t2 2)) (v (:t3 0))) ((n j) (n k)) nil)) (v (:t 0))) ((n type)))
        (((b (((v (:t 2))) ((n type)) :true)) (v (:t 0))) ((n type))))))
    #+end_src

* pass1

*** note scope

    - pass1 handles scope by
      by changing formal-var to var

    - in var there is unique id

*** pass1/arrow

    #+begin_src lisp
    (defun pass1/arrow (f s)
      ;; formal-arrow, scope -> arrow
      (match f
        (fac fsc) =>
        (match (pass1/cedent fac s)
          (ac s0) =>
          (match (pass1/cedent fsc s0)
            (sc s1) =>
            (list ac sc)))))
    #+end_src

*** pass1/cedent

    #+begin_src lisp
    (defun pass1/cedent (f s)
      ;; formal-cedent, scope -> (cedent scope)
      (match f
        () => (list () s)
        (h . r) =>
        (match (pass1/dispatch h s)
          (v s0) =>
          (match (pass1/cedent r s0)
            (c s1) =>
            (list (cons v c) s1)))))
    #+end_src

*** pass1/dispatch

    #+begin_src lisp
    (defun pass1/dispatch (f s)
      ;; formal-form, scope -> (form scope)
      (match f
        ('v v) => (pass1/var v s)
        ('n n) => (list (list 'name n) s)
        ('a a) => (list (list 'arrow (pass1/arrow a s)) s)
        ('b b) => (pass1/bind b s)))
    #+end_src

*** pass1/var

    #+begin_src lisp
    (defun pass1/var (v s)
      ;; formal-var, scope -> (var scope)
      (match v
        (symbol level) =>
        (let ((found (assoc symbol s :test #'eq)))
          (if found
              (let ((old (cdr found)))
                (list (list 'var (list old level)) s))
              (let ((new (vector symbol ())))
                (list (list 'var (list new level))
                      (cons (cons symbol new) s)))))))
    #+end_src

*** pass1/bind

    #+begin_src lisp
    (defun pass1/bind (b s)
      ;; formal-bind, scope -> (bind scope)
      (match b
        (fvs fc leave?) =>
        (match (pass1/cedent fvs s)
          (vs s0) =>
          (match (pass1/cedent fc s0)
            ;; this means vars in fvs can occur in fc
            (c s1) =>
            (list (list 'bind (list vs c leave?)) s1)))))
    #+end_src

*** test

    #+begin_src lisp
    (assert
     (equalp

      (list
       (pass1/arrow
        (parse/arrow '(natural natural -> natural))
        ())
       (pass1/arrow
        (parse/arrow '(natural natural -> (natural natural -> natural) natural))
        ())
       (pass1/arrow
        (parse/arrow '(:m zero -> :m))
        ())
       (pass1/arrow
        (parse/arrow '(:m :n succ -> :m :n recur succ))
        ())
       (pass1/arrow
        (parse/arrow '((:t :> type) :t -> type))
        ())
       (pass1/arrow
        (parse/arrow '((:t @ type) :t -> type))
        ())
       (pass1/arrow
        (parse/arrow '((:t^2 :> type) :t -> type))
        ())
       (pass1/arrow
        (parse/arrow '((:t1 :t2^2 :t3^0 :> j k) :t -> type))
        ())
       (pass1/arrow
        (parse/arrow '((:t^2 @ type) :t -> type))
        ())
       (pass1/arrow
        (parse/arrow '(:t (:t -> :t) -> (:t -> (:t -> :t) :t) type))
        ()))

      '((((name natural) (name natural)) ((name natural)))
        (((name natural) (name natural)) ((arrow (((name natural) (name natural)) ((name natural)))) (name natural)))
        (((var (#(:m nil) 0)) (name zero)) ((var (#(:m nil) 0))))
        (((var (#(:m nil) 0)) (var (#(:n nil) 0)) (name succ)) ((var (#(:m nil) 0)) (var (#(:n nil) 0)) (name recur) (name succ)))
        (((bind (((var (#(:t nil) 1))) ((name type)) nil)) (var (#(:t nil) 0))) ((name type)))
        (((bind (((var (#(:t nil) 1))) ((name type)) :true)) (var (#(:t nil) 0))) ((name type)))
        (((bind (((var (#(:t nil) 2))) ((name type)) nil)) (var (#(:t nil) 0))) ((name type)))
        (((bind (((var (#(:t1 nil) 1)) (var (#(:t2 nil) 2)) (var (#(:t3 nil) 0))) ((name j) (name k)) nil)) (var (#(:t nil) 0))) ((name type)))
        (((bind (((var (#(:t nil) 2))) ((name type)) :true)) (var (#(:t nil) 0))) ((name type)))
        (((var (#(:t nil) 0)) (arrow (((var (#(:t nil) 0))) ((var (#(:t nil) 0)))))) ((arrow (((var (#(:t nil) 0))) ((arrow (((var (#(:t nil) 0))) ((var (#(:t nil) 0))))) (var (#(:t nil) 0))))) (name type))))))
    #+end_src

* apply

*** id

    #+begin_src lisp
    (defun id->ls (id)
      (svref id 1))

    (defun id/commit! (id ls)
      (setf (svref id 1)
            (append ls (svref id 1))))
    #+end_src

*** apply/arrow

    #+begin_src lisp
    (defun apply/arrow (a e)
      ;; arrow, env -> env or nil
      (match e
        (ds bs ns) =>
        (match a
          (ac sc) =>
          (match (unify
                  (apply/cedent
                   ac
                   (list (cons 'unify-point ds)
                         (cons '(commit-point) bs)
                         ns)))
            (:fail _) => nil
            (:success e1)
            => (match (apply/cedent sc e1)
                 (ds2 bs2 ns2) =>
                 (labels ((recur (l) ;; side-effect on var
                            (cond ((equal '(commit-point) (car l))
                                   (cdr l))
                                  (:else
                                   (let* ((pair (car l))
                                          (id (car pair))
                                          (ls (cdr pair)))
                                     (id/commit! id ls)
                                     (recur (cdr l)))))))
                   (list ds2 (recur bs2) ns2)))))))
    #+end_src

*** apply/cedent

    #+begin_src lisp
    (defun apply/cedent (c e)
      ;; cedent, env -> env
      (match c
        () => e
        (h . r) => (apply/cedent r (apply/dispatch h e))))
    #+end_src

*** apply/dispatch

    #+begin_src lisp
    (defun apply/dispatch (f e)
      ;; form, env -> env
      (match f
        ('var v) => (apply/var v e)
        ('name n) => (apply/name n e)
        ('arrow a) => (apply/literal-arrow a e)
        ('bind b) => (apply/bind b e)))
    #+end_src

*** apply/literal-arrow

    #+begin_src lisp
    (defun apply/literal-arrow (a e)
      (match e
        (ds bs ns) =>
        (list (cons (list 'arrow a)
                    ds)
              bs
              ns)))
    #+end_src

*** apply/var

    #+begin_src lisp
    (defun apply/var (v e)
      ;; var, env -> env
      (match e
        (ds bs ns) =>
        (list (cons (bs/deep bs (list 'var v)) ds)
              bs
              ns)))
    #+end_src

*** apply/name

    #+begin_src lisp
    (defun apply/name (n e)
      ;; name, env -> env
      (match e
        (ds bs ns) =>
        (let ((found (assoc n ns :test #'eq)))
          (if (not found)
              (orz ()
                ("apply/name unknow name : ~a~%" n))
              (let ((store (cdr found)))
                (match store
                  ('function f)
                  => (apply/name/function f e)
                  ('type-constructor (formal-arrow arity data-name-list))
                  => (apply/arity n arity e)
                  ('data-constructor (formal-arrow arity type-name))
                  => (apply/arity n arity e)))))))
    #+end_src

*** apply/name/function

    #+begin_src lisp
    (defun apply/name/function (f e)
      ;; function, env -> env
      ;; need to do a pass1 here
      (match e
        (ds bs ns) =>
        (match f
          (formal-arrow arity formal-arrow-list) =>
          (apply/arrow-list (mapcar (lambda (x) (pass1/arrow x ()))
                                    formal-arrow-list)
                            e))))
    #+end_src

*** apply/arrow-list

    - trunk maybe be created here

    #+begin_src lisp
    (defun apply/arrow-list (arrow-list e)
      ;; arrow-list, env -> env or nil
      (match e
        (ds bs ns) =>
        (let* ((arity (arrow-list->arity arrow-list e))
               (data-list (subseq ds 0 arity))
               (arrow-list (apply/arrow-list/filter arrow-list data-list e)))
          (match arrow-list
            () => (orz ()
                    ("apply/arrow-list no match~%")
                    ("  arrow-list : ~a~%" arrow-list)
                    ("  data-list : ~a~%" data-list))
            (a) => (apply/arrow a e)
            (a1 a2 . _) =>
            (list (cons (list 'trunk
                              (list arrow-list
                                    data-list))
                        (subseq ds arity))
                  bs
                  ns)))))
    #+end_src

*** apply/arrow-list/filter

    - no commit should be made here

    #+begin_src lisp
    (defun apply/arrow-list/filter (arrow-list data-list e)
      ;; arrow-list, data-list, env -> arrow-list
      (if (eq () arrow-list)
          ()
          (match e
            (ds bs ns) =>
            (match (car arrow-list)
              (ac sc) =>
              (match (unify
                      (apply/cedent
                       ac
                       (list (cons 'unify-point
                                   (append data-list ds))
                             bs
                             ns)))
                (:fail _)
                => (apply/arrow-list/filter (cdr arrow-list) data-list e)
                (:success e1)
                => (cons (car arrow-list)
                         (apply/arrow-list/filter (cdr arrow-list) data-list e)))))))
    #+end_src

*** apply/arity

    #+begin_src lisp
    (defun apply/arity (n arity e)
      ;; name, arity, env -> env
      (match e
        (ds bs ns) =>
        (list (cons (list 'cons
                          (list n (subseq ds 0 arity)))
                    (subseq ds arity))
              bs
              ns)))
    #+end_src

*** apply/bind

    #+begin_src lisp
    (defun apply/bind (b e)
      ;; bind, env -> env
      (match b
        (vs c leave?) =>
        (match (apply/cedent c e)
          ((d1 . r1) bs1 ns1) =>
          (labels ((recur (vs e)
                     (match (list vs e)
                       (() _) => e
                       ((v . r) (ds bs ns)) =>
                       (recur r (list (if leave?
                                          (cons d1 ds)
                                          ds)
                                      (bs/extend 1 bs v d1)
                                      ns)))))
            (recur vs e)))))
    #+end_src

*** ><><>< bs/[extend|find|walk|deep]

    - 當需要 level n+1 時
      如果只有 level n 其實也是可以的
      - 用 typeof
      但是這些信息可能只有在 unify 時纔會用到
      所以現在不處理

    - default-level is handled here

    #+begin_src lisp
    (defun bs/find (bs v)
      ;; bs, var -> data or nil
      (match v
        (id level) =>
        (let* ((level (if (eq level nil)
                          0
                          level))
               (found/commit (assoc level (id->ls id) :test #'eq)))
          (if found/commit
              (cdr found/commit)
              (let* ((found/ls (assoc id bs :test #'eq))
                     (found/bind
                      (if found/ls
                          (assoc level (cdr found/ls) :test #'eq)
                          nil)))
                (if found/bind
                    (cdr found/bind)
                    nil))))))

    (defun bs/walk (bs d)
      ;; bs, data -> data
      (match d
        ('var v) => (let ((found (bs/find bs v)))
                      (if found
                          (bs/walk bs found)
                          d))
        (else e) => d))

    (defun bs/deep (bs d)
      ;; bs, data -> data
      (let ((d (bs/walk bs d)))
        (match d
          ('var v) => d
          ('arrow a) => d
          ('cons (name ds))
          => (list 'cons
                   (list name
                         (mapcar (lambda (x) (bs/deep bs x))
                                 ds)))
          ('trunk (arrow-list ds))
          => (list 'trunk
                   (list arrow-list
                         (mapcar (lambda (x) (bs/deep bs x))
                                 ds))))))

    (defun bs/extend (default-level bs v d)
      ;; bs var data -> bs
      (match v
        (id level) =>
        (let* ((level (if (eq nil level)
                          default-level
                          level))
               (found/ls (assoc id bs :test #'eq)))
          (if found/ls
              (substitute (cons id (cons (cons level d)
                                         (cdr found/ls)))
                          (lambda (pair) (eq (car pair) id))
                          bs)
              (cons (cons id (list (cons level d)))
                    bs)))))
    #+end_src

* unify

*** 記

    - unify 即 核心等詞

    - 當兩個都是 trunk 時
      有兩種 判斷相等的方式
      1. trunk 待作用函數相同 並且 data-list 也相同
      2. 其中一 trunk 可以計算 然後依舊 非兩個 trunk 的情形來判斷相等
      看來等詞是有很多細節的
      可能實現得越細越好

*** note unify-report

    - unify-report =
      - (:fail unify-report)
      - (:success env)

*** unify

    #+begin_src lisp
    (defun unify (e)
      ;; env -> unify-report
      (match e
        (ds bs ns) =>
        (let* ((l1 (left-of 'unify-point ds))
               (tmp (right-of 'unify-point ds))
               (len (length l1))
               (l2 (subseq tmp 0 len))
               (ds1 (subseq tmp len)))
          (unify/list l1 l2
                      (list :success (list ds1 bs ns))))))
    #+end_src

*** unify/list

    #+begin_src lisp
    (defun unify/list (l1 l2 unify-report)
      ;; data list, data list, unify-report -> unify-report
      (match unify-report
        (:fail report) => unify-report
        (:success e) =>
        (if (eq () l1)
            unify-report
            (unify/list (cdr l1) (cdr l2)
                        (unify/dispatch (car l1) (car l2) e)))))
    #+end_src

*** var/eq

    #+begin_src lisp
    (defun var/eq (v1 v2)
      (match (list v1 v2)
        ((id1 level1) (id2 level2)) =>
        (and (eq id1 id2)
             (eq level1 level2))))
    #+end_src

*** ><><>< unify/dispatch

    - 需要檢查 type

    #+begin_src lisp
    (defun unify/dispatch (d1 d2 e)
      ;; data, data, env -> unify-report
      (match e
        (ds bs ns) =>
        (let ((d1 (bs/walk bs d1))
              (d2 (bs/walk bs d2)))
          ;; walk then if it is var it will be fresh
          (match (list d1 d2)
            (('var v1) ('var v2))
            => (if (var/eq v1 v2)
                   (list :success e)
                   (list :success
                         (list ds (bs/extend 0 bs v1 d2) ns)))
            (('var v) d)
            => (list :success
                     (list ds (bs/extend 0 bs v d) ns))
            (d ('var v))
            => (list :success
                     (list ds (bs/extend 0 bs v d) ns))
            (('arrow a1) ('arrow a2))
            => (if (equal a1 a2)
                   (list :success
                         (list ds bs ns))
                   (list :fail
                         (list
                          `(unify/dispatch (:d1 ,d1)
                                           (:d2 ,d2)))))
            (('arrow a) _)
            => (list :fail
                     (list
                      `(unify/dispatch (:d1 ,d1)
                                       (:d2 ,d2))))
            (_ ('arrow a))
            => (list :fail
                     (list
                      `(unify/dispatch (:d1 ,d1)
                                       (:d2 ,d2))))
            (('cons (name1 data-list1)) ('cons (name2 data-list2)))
            => (if (eq name1 name2)
                   (unify/list data-list1 data-list2 (list :success e))
                   (list :fail
                         (list
                          `(unify/dispatch (:d1 ,d1)
                                           (:d2 ,d2)))))
            (('trunk trunk1) ('trunk trunk2)) => (unify/trunk/trunk trunk1 trunk2 e)
            (d ('trunk trunk)) => (unify/trunk/data trunk d e)
            (('trunk trunk) d) => (unify/trunk/data trunk d e)))))
    #+end_src

*** ><><>< unify/trunk/trunk

    - the use of equalp is not safe

    #+begin_src lisp
    (defun unify/trunk/trunk (trunk1 trunk2 e)
      ;; trunk, trunk, env -> unify-report
      (cat () ("here unify/trunk/trunk ~%"))
      (match (list trunk1 trunk2 e)
        ((arrow-list1 data-list1) (arrow-list2 data-list2) (ds bs ns)) =>
        (if (equalp arrow-list1 arrow-list2)
            ;; the use of equalp is not safe
            (unify/list data-list1 data-list2 (list :success e))
            (match (unify/trunk/data trunk1 (list 'trunk trunk2) e)
              (:success e1) => (list :success e1)
              (:fail _) =>
              (unify/trunk/data trunk2 (list 'trunk trunk1) e)))))
    #+end_src

*** ><><>< unify/trunk/data

    - trunk can only return one data

    #+begin_src lisp
    (defun unify/trunk/data (trunk d e)
      ;; trunk, data, env -> unify-report
      ;; where data is not trunk
      (cat () ("here unify/trunk/data ~%"))
      (match e
        (ds bs ns) =>
        (match trunk
          (arrow-list data-list) =>
          (let ((data-list1 (mapcar (lambda (x) (bs/deep bs x))
                                    data-list)))
            (match (apply/arrow-list/filter arrow-list data-list1 e)
              ()
              => (list :fail
                       (list
                        `(unify/dispatch
                          (:trunk-filter-to ())
                          (:trunk ,trunk)
                          (:data ,d))))
              (a)
              => (match (apply/arrow a (list data-list1 bs ns))
                   ((h . _) bs1 ns1)
                   => (unify/dispatch d h (list ds bs1 ns1)))
              (a1 a2 . _)
              => (list :fail
                       (list
                        `(unify/dispatch
                          (:trunk-filter-to
                           (:arrow-list
                            ,(apply/arrow-list/filter arrow-list data-list1 e))
                           (:data-list1 ,data-list1)
                           (:old-data-list ,data-list))
                          (:trunk ,trunk)
                          (:data ,d)))))))))
    #+end_src

* eva

*** eva

    #+begin_src lisp
    (defun eva (l e)
      ;; sexp-top list, env -> env
      (match l
        () => e
        (h . r) => (eva r (eva/top (parse/top h) e))))
    #+end_src

*** parse/top

    #+begin_src lisp
    (defun parse/top (s)
      ;; sexp-top -> top
      (match s
        ('dt name sexp-arrow . body)
        => (list 'dt
                 (list (list name (parse/arrow sexp-arrow))
                       (parse/top/dt-body body)))
        ('df name sexp-arrow . sexp-arrow-list)
        => (list 'df
                 (list (list name (parse/arrow sexp-arrow))
                       (mapcar #'parse/arrow sexp-arrow-list)))
        ('ap sexp-arrow)
        => (list 'ap (parse/arrow sexp-arrow))))
    #+end_src

*** parse/top/dt-body

    #+begin_src lisp
    (defun parse/top/dt-body (body)
      ;; sexp-top-dt-body -> ((formal-name formal-arrow) ...)
      (cond ((eq () body) ())
            ((eq () (cdr body))
             (orz ()
               ("parse/top/dt-body wrong body : body")))
            (:else
             (cons (list (car body) (parse/arrow (cadr body)))
                   (parse/top/dt-body (cddr body))))))
    #+end_src

*** test

    #+begin_src lisp
    (assert
     (equal

      (mapcar
       #'parse/top
       '((dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

         (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n recur succ))

         (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n recur :m add))

         (ap (->
              zero succ
              zero succ succ
              add))))

      '((dt ((natural (nil ((n type)))) ((zero (nil ((n natural)))) (succ (((n natural)) ((n natural)))))))
        (df ((add (((n natural) (n natural)) ((n natural)))) ((((v (:m 0)) (n zero)) ((v (:m 0)))) (((v (:m 0)) (v (:n 0)) (n succ)) ((v (:m 0)) (v (:n 0)) (n recur) (n succ))))))
        (df ((mul (((n natural) (n natural)) ((n natural)))) ((((v (:m 0)) (n zero)) ((n zero))) (((v (:m 0)) (v (:n 0)) (n succ)) ((v (:m 0)) (v (:n 0)) (n recur) (v (:m 0)) (n add))))))
        (ap (nil ((n zero) (n succ) (n zero) (n succ) (n succ) (n add)))))))


    (assert
     (equal

      (mapcar
       #'parse/top
       '((dt vector ((:t :> type) number :t -> type)
          null (-> zero :t vector)
          cons (:n :t vector :t -> :n succ :t vector))

         (df map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
          (null :f -> null)
          (:l :e cons :f -> :e :f apply :l :f map cons))

         (df append (:m :t vector :n :t vector -> :m :n add :t vector)
          (null :l -> :l)
          (:l :e cons :l1 -> :l :l1 append :e cons))))

      '((dt ((vector (((b (((v (:t 1))) ((n type)) nil)) (n number) (v (:t 0))) ((n type)))) ((null (nil ((n zero) (v (:t 0)) (n vector)))) (cons (((v (:n 0)) (v (:t 0)) (n vector) (v (:t 0))) ((v (:n 0)) (n succ) (v (:t 0)) (n vector)))))))
        (df ((map (((v (:n 0)) (v (:t1 0)) (n vector) (a (((v (:t1 0))) ((v (:t2 0)))))) ((v (:n 0)) (v (:t2 0)) (n vector)))) ((((n null) (v (:f 0))) ((n null))) (((v (:l 0)) (v (:e 0)) (n cons) (v (:f 0))) ((v (:e 0)) (v (:f 0)) (n apply) (v (:l 0)) (v (:f 0)) (n map) (n cons))))))
        (df ((append (((v (:m 0)) (v (:t 0)) (n vector) (v (:n 0)) (v (:t 0)) (n vector)) ((v (:m 0)) (v (:n 0)) (n add) (v (:t 0)) (n vector)))) ((((n null) (v (:l 0))) ((v (:l 0)))) (((v (:l 0)) (v (:e 0)) (n cons) (v (:l1 0))) ((v (:l 0)) (v (:l1 0)) (n append) (v (:e 0)) (n cons)))))))))
    #+end_src

*** eva/top

    #+begin_src lisp
    (defun eva/top (top e)
      ;; top, env -> env
      (match top
        ('dt type-definition) => (eva/dt type-definition e)
        ('df function-definition) => (eva/df function-definition e)
        ('ap formal-arrow) => (apply/arrow (pass1/arrow formal-arrow ()) e)))
    #+end_src

*** eva/dt

    #+begin_src lisp
    (defun eva/dt (type-definition e)
      ;; type-definition -> env
      (match e
        (ds bs ns) =>
        (match type-definition
          ((n a) l) =>
          (let* ((name-list
                  (mapcar #'car l))
                 (arity
                  (formal-arrow->arity a e))
                 (ns1
                  (cons (cons n
                              (list 'type-constructor
                                    (list a
                                          arity
                                          name-list)))
                        ns)))
            (eva/dt/data-constructor-list n l (list ds bs ns1))))))
    #+end_src

*** eva/dt/data-constructor & eva/dt/data-constructor-list

    #+begin_src lisp
    (defun eva/dt/data-constructor (type-name data-constructor e)
      ;; type-name, data-constructor, env -> env
      (match e
        (ds bs ns) =>
        (match data-constructor
          (n a) =>
          (list ds
                bs
                (cons (cons n
                            (list 'data-constructor
                                  (list a
                                        (formal-arrow->arity a e)
                                        type-name)))
                      ns)))))

    (defun eva/dt/data-constructor-list (type-name l e)
      ;; type-name, data-constructor-list, env -> env
      (match l
        () => e
        (h . r) =>
        (eva/dt/data-constructor-list
         type-name r
         (eva/dt/data-constructor type-name h e))))
    #+end_src

*** ><><>< formal-arrow->arity & arrow->arity & arrow-list->arity

    - 這裏假設了 antecedent 的計算中不會出現返回多個參數的 trunk
      因爲每個 trunk 被計爲一個 data
      但是其實返回多值的 trunk 應該被計爲多個 data

    - 也就是說 arity 這個 meta data 是不完全的
      完全的 arity 應該是包括返回值個數的

    - 但是在初期的實驗中我講不用到返回多值的函數
      初期實驗成功後再來修改這個錯誤

    #+begin_src lisp
    (defun formal-arrow->arity (formal-arrow e)
      ;; formal-arrow, env -> arity
      (match e
        (ds bs ns) =>
        (arrow->arity (pass1/arrow formal-arrow ()) e)))

    (defun arrow->arity (a e)
      ;; arrow, env -> arity
      (match e
        (ds bs ns) =>
        (match a
          (antecedent succedent) =>
          (match (apply/cedent antecedent
                               (list () bs ns))
            (ds1 bs1 ns1) =>
            (length ds1)))))

    (defun arrow-list->arity (l e)
      ;; arrow-list, env -> arity
      (match l
        (h . _) => (arrow->arity h e)))
    #+end_src

*** eva/df

    #+begin_src lisp
    (defun eva/df (function-definition e)
      ;; function-definition -> env
      (match e
        (ds bs ns) =>
        (match function-definition
          ((n a) l) =>
          (let ((ns1 (cons (cons n
                                 (list 'function
                                       (list a
                                             (formal-arrow->arity a e)
                                             l)))
                           ns)))
            (match (check a l (list ds bs ns1))
              ;; note that the bs of the env
              ;; returned by check is not clean
              (:success e1) => (list ds bs ns1)
              (:fail check-report) =>
              (orz ()
                ("eva/df fail to define : ~a~%" function-definition)
                ("check-report : ~a" check-report)))))))
    #+end_src

* check

*** note check-report

    - check-report =
      (:fail check-report)
      (:success env)

*** check

    #+begin_src lisp
    (defun check (type-formal-arrow l e)
      ;; type-formal-arrow, formal-arrow list, env -> check-report
      (match l
        () => (list :success e)
        (h . r) =>
        (match (check/arrow type-formal-arrow h e)
          (:success e) => (check type-formal-arrow r e)
          (:fail check-report) => (list :fail check-report))))
    #+end_src

*** check/arrow

    #+begin_src lisp
    (defun check/arrow (type-formal-arrow a e)
      ;; type-formal-arrow, formal-arrow, env -> check-report
      (match (pass1/arrow type-formal-arrow ())
        (tac tsc) =>
        (match (apply/cedent tac e)
          (ds0 bs0 ns0) =>
          (match (pass1/arrow a ())
            (ac sc) =>
            (match (unify
                    (type-apply/cedent
                     ac
                     (list (cons 'unify-point ds0)
                           bs0
                           ns0)))
              (:fail report)
              => (list :fail
                       (cons `(check/arrow
                               (:type-antecedent ,tac)
                               (:antecedent ,ac))
                             report))
              (:success e1)
              => (let* ((e2 (type-apply/cedent sc e1)))
                   (match e2
                     (ds2 bs2 ns2) =>
                     (match (unify
                             (apply/cedent
                              tsc
                              (list (cons 'unify-point ds2)
                                    bs2
                                    ns2)))
                       (:success e) => (list :success e)
                       (:fail report)
                       => (list :fail
                                (cons `(check/arrow
                                        (:type-succedent ,tsc)
                                        (:succedent ,sc))
                                      report))))))))))
    #+end_src

* type-apply

*** type-apply/cedent

    #+begin_src lisp
    (defun type-apply/cedent (c e)
      ;; cedent, env -> env
      (match c
        () => e
        (h . r) => (type-apply/cedent r (type-apply/dispatch h e))))
    #+end_src

*** ><><>< type-apply/dispatch

    #+begin_src lisp
    (defun type-apply/dispatch (f e)
      ;; form, env -> env
      (match f
        ('var v) => (type-apply/var v e)
        ('name n) => (type-apply/name n e)
        ('arrow a) => ;; (type-apply/literal-arrow a e)
        (orz ()
          ("type-apply/dispatch can not type-apply literal-arrow for now"))
        ('bind b) => ;; (type-apply/bind b e)
        (orz ()
          ("type-apply/dispatch can not type-apply bind for now"))))
    #+end_src

*** type-apply/var

    #+begin_src lisp
    (defun type-apply/var (v e)
      ;; var, env -> env
      (match v
        (id level) =>
        (apply/var (if (eq level nil)
                       (list id 1)
                       (list id (+ 1 level)))
                   e)))
    #+end_src

*** type-apply/name

    #+begin_src lisp
    (defun type-apply/name (n e)
      ;; name, env -> env
      (match e
        (ds bs ns) =>
        (let ((found (assoc n ns :test #'eq)))
          (if (not found)
              (orz ()
                ("type-apply/name unknow name : ~a~%" n))
              (let ((store (cdr found)))
                (match store
                  (any-store (formal-arrow arity . _)) =>
                  (apply/arrow (pass1/arrow formal-arrow ()) e)))))))
    #+end_src

*** >< type-apply/literal-arrow
*** >< type-apply/bind
*** >< typeof

* sequent

  #+begin_src lisp
  (defmacro sequent (&body body)
    `(eva (quote ,body)
         '(() () ())))
  #+end_src

* test

*** natural

    #+begin_src lisp :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (ap (->
           zero succ
           zero succ succ
           add))

      (ap (->
           zero succ succ
           zero succ succ
           mul))

      (ap (-> mul)))
    #+end_src

*** list

    #+begin_src lisp :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt list ((:t :> type) :t -> type)
          null (-> :t list)
          cons (:t list :t -> :t list))

      ;; (df map (:t1 list (:t1 -> :t2) -> :t2 list)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:t list :t list -> :t1 list)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src

*** vector

    #+begin_src lisp :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt vector ((:t :> type) natural :t -> type)
          null (-> zero :t vector)
          cons (:n :t vector :t -> :n succ :t vector))

      ;; (df map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:m :t vector :n :t vector -> :m :n add :t vector)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src
