+ sequent1
  sequent calculus as dependent type system of functional language

+ this is a prototype
  it is not useful for it is lack of so many important features

+ XIE Yuheng created

#+PROPERTY: tangle sequent1.ml

* formal_arrow

  #+begin_src caml
  type formal_name = string ;;
  type formal_var = string ;;

  type formal_arrow = formal_cedent * formal_cedent
  and formal_cedent = formal_form list
  and formal_bind = formal_var * formal_cedent * bool
  and formal_form =
    | N of formal_name
    | V of formal_var
    | A of formal_arrow
    | B of formal_bind
  ;;
  #+end_src

* formal_top

  #+begin_src caml
  type formal_top =
    | DT of (formal_name * formal_arrow) * (formal_name * formal_arrow) list
    | DF of (formal_name * formal_arrow) * formal_arrow list
    | AP of formal_arrow
  ;;
  #+end_src

* arrow

  #+begin_src caml
  type var = string array * int ;;
  type name = string ;;

  type arrow = cedent * cedent
  and cedent = form list
  and bind = var * cedent * bool
  and form =
    | NAME  of name
    | VAR   of var
    | ARROW of arrow
    | BIND  of bind
  ;;
  #+end_src

* data

  #+begin_src caml
  type data =
    | VAR of var
    | ARROW of arrow
    | CONS of name * data list
    | TRUNK of name * data list
  ;;
  #+end_src

* store

  #+begin_src caml
  type store =
    | FUNCTION of formal_arrow * formal_arrow list
    | TYPE_CONSTRUCTOR of formal_arrow * int * name list
    | DATA_CONSTRUCTOR of formal_arrow * int * name
  ;;
  #+end_src

* env

  #+begin_src caml
  type env
  = data list
  * (var * data) list
  * (name * store) list
  ;;
  #+end_src

* >< parse_arrow

  #+begin_src caml
  let parse_arrow
  : formal_arrow -> arrow
  = fun fa ->
    match fa with
    | fac, fsc -> ()
  ;;
  #+end_src

* var

* ds

* bs

* ns

* apply_arrow

  #+begin_src caml
  let apply_arrow
  : arrow -> env -> env
  = fun a e ->
    match a, e with
    | (ac, sc), (ds, bs, ns) ->

  ;;


  #+end_src

* eval

  #+begin_src caml
  let rec eval
  : formal_top list -> env -> env
  = fun fs e ->
    match fs with
    | [] -> e
    | h :: r -> eval r (eval_formal_top h e)

  and eval_formal_top
  : formal_top -> env -> env
  = fun f e ->
    match f, e with
    | DT ((fn, fa), fnfas), (ds, bs, ns) ->
      (ds, bs, (add_  ns))
    | DF ((fn, fa), fas), (ds, bs, ns) ->
      ()
    | AP (fa), (ds, bs, ns) ->
      (apply_arrow (parse_arrow fa) e)
  ;;

  let
  :
  = fun ->
    match  with
    |
    |
    |
  ;;
  #+end_src

* note example

*** sexp natural

    #+begin_src scheme :tangle no
    (dt
      natural (-> type)
      zero (-> natural)
      succ (natural -> natural))

    (df add
      (natural natural -> natural)
      (:m zero -> :m)
      (:m :n succ -> :m :n recur succ))

    (df mul
      (natural natural -> natural)
      (:m zero -> zero)
      (:m :n succ -> :m :n recur :m add))
    #+end_src

*** natural

    #+begin_src caml :tangle no
    DT
    ( ("natural", ([], [N("type")]))
    , [ ("zero", ([], [N("natural")]))
      ; ("succ", ([N("natural")], [N("natural")]))
      ]
    ) ;;

    DF
    ( ("add", ([N("natural"); N("natural")], [N("natural")]))
    , [ ([V(":m"); N("zero")], [V(":m")])
      ; ([V(":m"); V(":n"); N("succ")], [V(":m"); V(":n"); N("add"); N("succ")])
      ]
    ) ;;

    DF
    ( ("mul", ([N("natural"); N("natural")], [N("natural")]))
    , [ ([V(":m"); N("zero")], [N("zero")])
      ; ([V(":m"); V(":n"); N("succ")], [V(":m"); V(":n"); N("mul"); N("add")])
      ]
    ) ;;
    #+end_src

*** sexp list

    #+begin_src scheme :tangle no
    (dt
      list ({:t ~ type} :t -> type)
      null (-> :t list)
      cons (:t list :t -> :t list))

    (df map
      (:t1 list (:t1 -> :t2) -> :t2 list)
      (null :f -> null)
      (:l :e cons :f -> :e :f apply :l :f map cons))

    (df append
      (:t list :t list -> :t1 list)
      (null :l -> :l)
      (:l :e cons :l1 -> :l :l1 append :e cons))
    #+end_src

*** >< list

    #+begin_src caml :tangle no
    DT
    ( ("list", ([B(V(":t"), [N("type")], false); V(":t")], [N("type")]))
    , [ ("null", ([], [V(":t"); N("list")]))
      ; ("cons", ([V(":t"); N("list"); V(":t")], [V(":t"); N("list")]))
      ]
    ) ;;



    DF
    ( ("map", ([V(":t1"); N("list"); A([V(":t1")], [V(":t2")])],
               [V(":t2"); N("list")]))
    , [ ([], []) (null :f -> null)
      ; ([], []) (:l :e cons :f -> :e :f apply :l :f map cons)
      ]
    ) ;;

    DF
    ( ("append", ([], []))
    , [ ([], [])
      ; ([], [])
      ]
    ) ;;
    #+end_src

*** sexp has-length

    #+begin_src scheme :tangle no
    (dt
      has-length ({:t ~ type} :t list natural -> type)
      null/has-length (-> null zero has-length)
      cons/has-length (:l :n has-length -> :l :a cons :n succ has-length))

    (df map/has-length
      (:l :n has-length -> :l :f map :n has-length)
      (null/has-length -> null/has-length)
      (:h cons/has-length -> :h map/has-length cons/has-length))
    #+end_src

*** >< has-length

    #+begin_src caml :tangle no

    #+end_src

*** sexp vector

    #+begin_src scheme :tangle no
    (dt
      vector ({:t ~ type} number :t -> type)
      null (-> zero :t vector)
      cons (:n :t vector :t -> :n succ :t vector))

    (df map
      (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      (null :f -> null)
      (:l :e cons :f -> :e :f apply :l :f map cons))

    (df append
      (:m :t vector :n :t vector -> :m :n add :t vector)
      (null :l -> :l)
      (:l :e cons :l1 -> :l :l1 append :e cons))
    #+end_src

*** >< vector

    #+begin_src caml :tangle no

    #+end_src
