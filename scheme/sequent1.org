+ sequent calculus as dependent type system of functional language

+ a prototype interpreter

+ XIE Yuheng created

#+PROPERTY: tangle sequent1.scm

* todo

* note sequent

  - sequent is arrow
    which is the core data type of the language

* note data type

*** formal-form

    - formal-arrow = (formal-cedent formal-cedent)
    - formal-cedent = (formal-form ...)
    - formal-form =
      - ('v formal-var)
      - ('n formal-name)
      - ('a formal-arrow)
      - ('b formal-bind)
    - formal-var = (symbol level)
    - formal-name = symbol
    - formal-bind = ((formal-var ...) formal-cedent leave?)
    - level = natural-number

*** form

    - arrow = (cedent cedent)
    - cedent = (form ...)
    - form =
      - ('var var)
      - ('name name)
      - ('arrow arrow)
      - ('bind bind)
    - var = (id level)
    - name = symbol
    - bind = ((var ...) cedent leave?)
    - id = #(symbol ls)

*** env

    - env = (ds bs ns)
    - ds = (data ...)
    - bs = ((id . ls) ...)
      - ls = ((level . data) ...)
    - ns = ((name . function) ...)

*** data

    - data =
      - ('var var)
      - ('cons (name (data ...)))
      - ('trunk (function (arrow ...) (data ...)))

*** function

    - function =
      - ('normal-function normal-function)
      - ('type-constructor type-constructor)
      - ('data-constructor data-constructor)
    - normal-function = (formal-arrow arity (formal-arrow ...))
    - type-constructor = (formal-arrow arity (name ...))
    - data-constructor = (formal-arrow arity name)
    - arity = (number number)

*** top

    - top =
      - ('dt type-definition)
      - ('df function-definition)
      - ('ap formal-arrow)
    - type-definition =
      ((formal-name formal-arrow) ((formal-name formal-arrow) ...))
    - function-definition =
      ((formal-name formal-arrow) (formal-arrow ...))

*** unify-report

    - unify-report =
      - ('fail (report ...))
      - ('success (report ...) env)
    - report = ?

* helper

*** pattern match

    #+begin_src scheme
    ;; module system of guile
    ;; using http://synthcode.com/scheme/match.scm
    (use-modules (ice-9 match))
    #+end_src

*** cat & orz

    #+begin_src scheme
    (define-syntax cat
      (syntax-rules ()
        [(cat (str . args))
         (format #t str . args)]
        [(cat (str . args) (str2 . args2) ...)
         (string-append
          (cat (str . args))
          (cat (str2 . args2) ...))]))

    (define-syntax orz
      (syntax-rules ()
        [(orz . body)
         (error (cat . body))]))

    (define-syntax note
      (syntax-rules ()
        [(note . body)
         '()]))
    #+end_src

*** testing

    #+begin_src scheme
    (use-modules (ice-9 pretty-print))

    (define-syntax test
      (syntax-rules ()
        [(test b1 b2)
         (if (equal? b1 b2)
           #t
           (let ()
             (cat ("\n"))
             (cat ("<test-fail-report-begin>\n"))
             (cat ("<actual-form> :\n"))
             (pretty-print (quote b1))
             (cat ("<actual-value> :\n"))
             (pretty-print b1)
             (cat ("<expect-form> :\n"))
             (pretty-print (quote b2))
             (cat ("<expect-value> :\n"))
             (pretty-print b2)
             (orz ("<test-fail-report-end>\n"))))]))
    #+end_src

*** list

    #+begin_src scheme
    (define (left-of s l)
      ;; sexp, list -> list
      (cond [(equal? s (car l)) '()]
            [else (cons (car l) (left-of s (cdr l)))]))

    (define (right-of s l)
      ;; sexp, list -> list
      (cond [(equal? s (car l)) (cdr l)]
            [else (right-of s (cdr l))]))
    #+end_src

*** string

    #+begin_src scheme
    (define (find-char c s)
      ;; char, string -> curser or #f
      (find-char/curser c s 0))

    (define (find-char/curser c s curser)
      ;; char, string, curser -> curser or #f
      (if (>= curser (string-length s))
        #f
        (let ([c0 (substring s curser (+ 1 curser))])
          (if (equal? c c0)
            curser
            (find-char/curser c s (+ 1 curser))))))
    #+end_src

* parse

*** note

    - sexp -> formal (i.e. AST)

*** parse/arrow

    #+begin_src scheme
    (define (parse/arrow s)
      ;; sexp-arrow -> formal-arrow
      (list (parse/cedent 0 (left-of '-> s))
            (parse/cedent 0 (right-of '-> s))))
    #+end_src

*** parse/cedent

    #+begin_src scheme
    (define (parse/cedent default-level s)
      ;; default-level, sexp-cedent -> formal-cedent
      (match s
        ['() '()]
        [(h . r) (cons (parse/dispatch default-level h)
                       (parse/cedent default-level r))]))
    #+end_src

*** parse/dispatch

    #+begin_src scheme
    (define (parse/dispatch default-level v)
      ;; default-level, sexp-form -> formal-form
      (let ([var? (lambda (v)
                    (and (symbol? v)
                         (equal? ":" (substring (symbol->string v) 0 1))))]
            [name? (lambda (v)
                     (and (symbol? v)
                          (not (eq? ":" (substring (symbol->string v) 0 1)))))]
            [arrow? (lambda (v) (and (list? v) (member '-> v)))]
            [im-bind? (lambda (v) (and (list? v) (member ': v)))]
            [ex-bind? (lambda (v) (and (list? v) (member '@ v)))])
        (cond [(var? v) (list 'v (parse/var default-level v))]
              [(name? v) (list 'n v)]
              [(arrow? v) (list 'a (parse/arrow v))]
              [(im-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of ': v))
                                        (parse/cedent 0 (right-of ': v))
                                        #f))]
              [(ex-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of '@ v))
                                        (parse/cedent 0 (right-of '@ v))
                                        #t))]
              [else (orz ("parse/dispatch can not handle sexp-form:~a" v))])))
    #+end_src

*** parse/var

    #+begin_src scheme
    (define (parse/var default-level v)
      ;; default-level, symbol -> formal-var
      (let* ([str (symbol->string v)]
             [cursor (find-char "^" str)])
        (if cursor
          (list (string->symbol (substring str 0 cursor))
                (string->number (substring str (+ 1 cursor))))
          (list v default-level))))
    #+end_src

*** test

    #+begin_src scheme
    (test
     (list
      (parse/arrow '(natural natural -> natural))
      (parse/arrow '(natural natural -> (natural natural -> natural) natural))
      (parse/arrow '(:m zero -> :m))
      (parse/arrow '(:m :n succ -> :m :n recur succ))
      (parse/arrow '((:t : type) :t -> type))
      (parse/arrow '((:t @ type) :t -> type))
      (parse/arrow '((:t^2 : type) :t -> type))
      (parse/arrow '((:t1 :t2^2 :t3^0 : j k) :t -> type))
      (parse/arrow '((:t^2 @ type) :t -> type)))
     '((((n natural) (n natural)) ((n natural)))
       (((n natural) (n natural)) ((a (((n natural) (n natural)) ((n natural)))) (n natural)))
       (((v (:m 0)) (n zero)) ((v (:m 0))))
       (((v (:m 0)) (v (:n 0)) (n succ)) ((v (:m 0)) (v (:n 0)) (n recur) (n succ)))
       (((b (((v (:t 1))) ((n type)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t 1))) ((n type)) #t)) (v (:t 0))) ((n type)))
       (((b (((v (:t 2))) ((n type)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t1 1)) (v (:t2 2)) (v (:t3 0))) ((n j) (n k)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t 2))) ((n type)) #t)) (v (:t 0))) ((n type)))))
    #+end_src

* >< pass1

*** ><

    #+begin_src scheme

    #+end_src

* >< apply

*** ><

    #+begin_src scheme

    #+end_src

* >< unify

*** ><

    #+begin_src scheme

    #+end_src

* >< eva

* >< check

* >< sequent

* test

*** natural

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (ap (->
           zero succ
           zero succ succ
           add))

      (ap (->
           zero succ succ
           zero succ succ
           mul))

      (ap (-> mul)))
    #+end_src

*** list

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt list ((:t : type) :t -> type)
          null (-> :t list)
          cons (:t list :t -> :t list))

      ;; (df map (:t1 list (:t1 -> :t2) -> :t2 list)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:t list :t list -> :t1 list)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src

*** vector

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt vector ((:t : type) natural :t -> type)
          null (-> zero :t vector)
          cons (:n :t vector :t -> :n succ :t vector))

      ;; (df map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:m :t vector :n :t vector -> :m :n add :t vector)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src
