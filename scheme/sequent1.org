#+HTML_HEAD: <link rel="stylesheet" href="../asset/css/page.css" type="text/css" media="screen" />

#+title: sequent1

+ a prototype interpreter for a functional language
  which uses sequent calculus as dependent type system

+ XIE Yuheng created

#+PROPERTY: tangle sequent1.scm

* todo

  - data/print
    different var should be print differently

  - check-type
    infer-arity
    check-cover
    check-end

* note sequent

  - sequent is arrow
    which is the core data type of the language

* note data type

*** form1

    - form1 =
      - form1/var =
        :var
        :var^n
      - form1/name =
        name
      - form1/arrow =
        (form1 ... -> form1 ...)
      - form1/lambda =
        (lambda form1/arrow
          form1/arrow
          ...)
      - form1/bind =
        (form1/var ... : form1 ...)
        (form1/var ... @ form1 ...)

*** form2

    - form2 =
      ('form2/var    (symbol level))
      ('form2/name   symbol)
      ('form2/arrow  ((form2 ...) (form2 ...)))
      ('form2/lambda (form2/arrow (form2/arrow ...)))
      ('form2/bind   ((form2/var ...) (form2 ...) leave?))
    - level = natural-number

*** data

    - data =
      ('var    (id level))
      ('cons   (name (data ...)))
      ('arrow  ((data ...) (data ...)))
      ('lambda (arrow arity (arrow ...)))
      ('trunk  (arrow arity (arrow ...) (data ...)))
    - id = #(symbol ls)
    - arity = (number number)

*** env

    - env = (ds bs ns)
    - ds = (data ...)
    - bs = ((id . ls) ...)
      - ls = ((level . data) ...)
    - ns = ((name . meaning) ...)

*** meaning

    - meaning =
      ('lambda    (arrow arity (arrow ...)))
      ('cons/type (arrow arity name (name ...)))
      ('cons/data (arrow arity name name))

*** top1

    - top1 =
      ('dt ((form1/name form1/arrow) ((form1/name form1/arrow) ...)))
      ('df ((form1/name form1/arrow) (form1/arrow ...)))
      ('ap form1/arrow)

*** top2

    - top2 =
      ('top2/dt ((form2/name form2/arrow) ((form2/name form2/arrow) ...)))
      ('top2/df ((form2/name form2/arrow) (form2/arrow ...)))
      ('top2/ap form2/arrow)

*** report

    - report =
      ('fail (info ...))
      ('success (info ...) env)
    - info = ?

* note old data type

*** formal-form

    - formal-arrow = (formal-cedent formal-cedent)
    - formal-cedent = (formal-form ...)
    - formal-form =
      - ('v formal-var)
      - ('n formal-name)
      - ('t type)
      - ('l lambda)
      - ('b formal-bind)
    - formal-var = (symbol level)
    - formal-name = symbol
    - formal-type = formal-arrow
    - formal-lambda = ()
    - formal-bind = ((formal-var ...) formal-cedent leave?)
    - level = natural-number

*** form

    - arrow = (cedent cedent)
    - cedent = (form ...)
    - form =
      - ('var var)
      - ('name name)
      - ('arrow arrow)
      - ('bind bind)
    - var = (id level)
    - name = symbol
    - bind = ((var ...) cedent leave?)
    - id = #(symbol ls)

*** env

    - env = (ds bs ns)
    - ds = (data ...)
    - bs = ((id . ls) ...)
      - ls = ((level . data) ...)
    - ns = ((name . function) ...)

*** data

    - data =
      - ('var var)
      - ('cons (name (data ...)))
      - ('arrow arrow)
      - ('lambda lambda)
      - ('trunk ((arrow ...) (data ...)))

*** function

    - function =
      - ('lambda lambda)
      - ('type-constructor type-constructor)
      - ('data-constructor data-constructor)
    - lambda = (formal-arrow arity (formal-arrow ...))
    - type-constructor = (formal-arrow arity (name ...))
    - data-constructor = (formal-arrow arity name)
    - arity = (number number)

*** top

    - top =
      - ('dt type-definition)
      - ('df function-definition)
      - ('ap formal-arrow)
    - type-definition =
      ((formal-name formal-arrow) ((formal-name formal-arrow) ...))
    - function-definition =
      ((formal-name formal-arrow) (formal-arrow ...))

*** report

    - report =
      - ('fail (info ...))
      - ('success (info ...) env)
    - info = ?

* helper

*** pattern match

    #+begin_src scheme
    ;; module system of guile
    ;; using http://synthcode.com/scheme/match.scm
    (use-modules (ice-9 match))
    #+end_src

*** cat & orz

    #+begin_src scheme
    (define-syntax cat
      (syntax-rules ()
        [(cat (str . args))
         (format #t str . args)]
        [(cat (str . args) (str2 . args2) ...)
         (string-append
          (cat (str . args))
          (cat (str2 . args2) ...))]))

    (define-syntax orz
      (syntax-rules ()
        [(orz . body)
         (error (cat . body))]))

    (define-syntax note
      (syntax-rules ()
        [(note . body)
         '()]))
    #+end_src

*** testing

    #+begin_src scheme
    (use-modules (ice-9 pretty-print))

    (define-syntax test
      (syntax-rules ()
        [(test b1 b2)
         (if (equal? b1 b2)
           #t
           (let ()
             (cat ("\n"))
             (cat ("<test-fail-report-begin>\n"))
             (cat ("<actual-form> :\n"))
             (pretty-print (quote b1))
             (cat ("<actual-value> :\n"))
             (pretty-print b1)
             (cat ("<expect-form> :\n"))
             (pretty-print (quote b2))
             (cat ("<expect-value> :\n"))
             (pretty-print b2)
             (orz ("<test-fail-report-end>\n"))))]))
    #+end_src

*** list

    #+begin_src scheme
    (define (left-of s l)
      ;; sexp, list -> list
      (cond [(equal? s (car l)) '()]
            [else (cons (car l) (left-of s (cdr l)))]))

    (define (right-of s l)
      ;; sexp, list -> list
      (cond [(equal? s (car l)) (cdr l)]
            [else (right-of s (cdr l))]))
    #+end_src

*** string

    #+begin_src scheme
    (define (find-char c s)
      ;; char, string -> curser or #f
      (find-char/curser c s 0))

    (define (find-char/curser c s curser)
      ;; char, string, curser -> curser or #f
      (if (>= curser (string-length s))
        #f
        (let ([c0 (substring s curser (+ 1 curser))])
          (if (equal? c c0)
            curser
            (find-char/curser c s (+ 1 curser))))))
    #+end_src

* parse

*** note

    - sexp -> formal (i.e. AST)

*** parse/arrow

    #+begin_src scheme
    (define (parse/arrow s)
      ;; sexp-arrow -> formal-arrow
      (list (parse/cedent 0 (left-of '-> s))
            (parse/cedent 0 (right-of '-> s))))
    #+end_src

*** parse/cedent

    #+begin_src scheme
    (define (parse/cedent default-level s)
      ;; default-level, sexp-cedent -> formal-cedent
      (match s
        ['() '()]
        [(h . r) (cons (parse/dispatch default-level h)
                       (parse/cedent default-level r))]))
    #+end_src

*** parse/dispatch

    #+begin_src scheme
    (define (parse/dispatch default-level v)
      ;; default-level, sexp-form -> formal-form
      (let ([var? (lambda (v)
                    (and (symbol? v)
                         (equal? ":" (substring (symbol->string v) 0 1))))]
            [name? (lambda (v)
                     (and (symbol? v)
                          (not (eq? ":" (substring (symbol->string v) 0 1)))))]
            [arrow? (lambda (v) (and (list? v) (member '-> v)))]
            [im-bind? (lambda (v) (and (list? v) (member ': v)))]
            [ex-bind? (lambda (v) (and (list? v) (member '@ v)))])
        (cond [(var? v) (list 'v (parse/var default-level v))]
              [(name? v) (list 'n v)]
              [(arrow? v) (list 'a (parse/arrow v))]
              [(im-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of ': v))
                                        (parse/cedent 0 (right-of ': v))
                                        #f))]
              [(ex-bind? v) (list 'b
                                  (list (parse/cedent 1 (left-of '@ v))
                                        (parse/cedent 0 (right-of '@ v))
                                        #t))]
              [else (orz ("parse/dispatch can not handle sexp-form:~a" v))])))
    #+end_src

*** parse/var

    #+begin_src scheme
    (define (parse/var default-level v)
      ;; default-level, symbol -> formal-var
      (let* ([str (symbol->string v)]
             [cursor (find-char "^" str)])
        (if cursor
          (list (string->symbol (substring str 0 cursor))
                (string->number (substring str (+ 1 cursor))))
          (list v default-level))))
    #+end_src

*** test

    #+begin_src scheme
    (test
     (list
      (parse/arrow '(natural natural -> natural))
      (parse/arrow '(natural natural -> (natural natural -> natural) natural))
      (parse/arrow '(:m zero -> :m))
      (parse/arrow '(:m :n succ -> :m :n recur succ))
      (parse/arrow '((:t : type) :t -> type))
      (parse/arrow '((:t @ type) :t -> type))
      (parse/arrow '((:t^2 : type) :t -> type))
      (parse/arrow '((:t1 :t2^2 :t3^0 : j k) :t -> type))
      (parse/arrow '((:t^2 @ type) :t -> type)))
     '((((n natural) (n natural)) ((n natural)))
       (((n natural) (n natural)) ((a (((n natural) (n natural)) ((n natural)))) (n natural)))
       (((v (:m 0)) (n zero)) ((v (:m 0))))
       (((v (:m 0)) (v (:n 0)) (n succ)) ((v (:m 0)) (v (:n 0)) (n recur) (n succ)))
       (((b (((v (:t 1))) ((n type)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t 1))) ((n type)) #t)) (v (:t 0))) ((n type)))
       (((b (((v (:t 2))) ((n type)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t1 1)) (v (:t2 2)) (v (:t3 0))) ((n j) (n k)) #f)) (v (:t 0))) ((n type)))
       (((b (((v (:t 2))) ((n type)) #t)) (v (:t 0))) ((n type)))))
    #+end_src

* pass1

*** note scope

    - pass1 handles scope by
      by changing formal-var to var

    - in var there is unique id

*** pass1/arrow

    #+begin_src scheme
    (define (pass1/arrow f s)
      ;; formal-arrow, scope -> arrow
      (match f
        [(fac fsc)
         (match (pass1/cedent fac s)
           [(ac s0)
            (match (pass1/cedent fsc s0)
              [(sc s1)
               (list ac sc)])])]))
    #+end_src

*** pass1/cedent

    #+begin_src scheme
    (define (pass1/cedent f s)
      ;; formal-cedent, scope -> (cedent scope)
      (match f
        ['() (list '() s)]
        [(h . r)
         (match (pass1/dispatch h s)
           [(v s0)
            (match (pass1/cedent r s0)
              [(c s1)
               (list (cons v c) s1)])])]))
    #+end_src

*** pass1/dispatch

    #+begin_src scheme
    (define (pass1/dispatch f s)
      ;; formal-form, scope -> (form scope)
      (match f
        [('v v) (pass1/var v s)]
        [('n n) (list (list 'name n) s)]
        [('a a) (list (list 'arrow (pass1/arrow a s)) s)]
        [('b b) (pass1/bind b s)]))
    #+end_src

*** pass1/var

    #+begin_src scheme
    (define (pass1/var v s)
      ;; formal-var, scope -> (var scope)
      (match v
        [(symbol level)
         (let ([found (assq symbol s)])
           (if found
             (let ([old (cdr found)])
               (list (list 'var (list old level)) s))
             (let ([new (vector symbol '())])
               (list (list 'var (list new level))
                     (cons (cons symbol new) s)))))]))
    #+end_src

*** pass1/bind

    #+begin_src scheme
    (define (pass1/bind b s)
      ;; formal-bind, scope -> (bind scope)
      (match b
        [(fvs fc leave?)
         (match (pass1/cedent fvs s)
           [(vs s0)
            (match (pass1/cedent fc s0)
              ;; this means vars in fvs can occur in fc
              [(c s1)
               (list (list 'bind (list vs c leave?)) s1)])])]))
    #+end_src

*** test

    #+begin_src scheme
    (test
     (map (lambda (x) (pass1/arrow x '()))
       (list
        (parse/arrow '(natural natural -> natural))
        (parse/arrow '(natural natural -> (natural natural -> natural) natural))
        (parse/arrow '(:m zero -> :m))
        (parse/arrow '(:m :n succ -> :m :n recur succ))
        (parse/arrow '((:t : type) :t -> type))
        (parse/arrow '((:t @ type) :t -> type))
        (parse/arrow '((:t^2 : type) :t -> type))
        (parse/arrow '((:t1 :t2^2 :t3^0 : j k) :t -> type))
        (parse/arrow '((:t^2 @ type) :t -> type))))
     '((((name natural) (name natural))
        ((name natural)))
       (((name natural) (name natural))
        ((arrow (((name natural) (name natural))
                 ((name natural))))
         (name natural)))
       (((var (#(:m ()) 0)) (name zero))
        ((var (#(:m ()) 0))))
       (((var (#(:m ()) 0)) (var (#(:n ()) 0)) (name succ))
        ((var (#(:m ()) 0)) (var (#(:n ()) 0)) (name recur) (name succ)))
       (((bind (((var (#(:t ()) 1))) ((name type)) #f)) (var (#(:t ()) 0)))
        ((name type)))
       (((bind (((var (#(:t ()) 1))) ((name type)) #t)) (var (#(:t ()) 0)))
        ((name type)))
       (((bind (((var (#(:t ()) 2))) ((name type)) #f)) (var (#(:t ()) 0)))
        ((name type)))
       (((bind (((var (#(:t1 ()) 1)) (var (#(:t2 ()) 2)) (var (#(:t3 ()) 0))) ((name j) (name k)) #f)) (var (#(:t ()) 0)))
        ((name type)))
       (((bind (((var (#(:t ()) 2))) ((name type)) #t)) (var (#(:t ()) 0)))
        ((name type)))))
    #+end_src

* apply

*** apply/arrow

    - apply/arrow is the only function that do commit

    - it returns report instead of env or #f
      because when calling it
      it is more easy to forget to handle the #f returned

    #+begin_src scheme
    (define (apply/arrow a e)
      ;; arrow, env -> report
      (match e
        [(ds bs ns)
         (match a
           [(ac sc)
            (match (unify (lambda (e) (apply/cedent ac e))
                          (list ds
                                (cons '(commit-point) bs)
                                ns))
              [('fail info-list) ('fail info-list)]
              [('success info-list e1)
               (match (apply/cedent sc e1)
                 [(ds2 bs2 ns2)
                  (list 'success info-list
                        (list ds2 (bs/commit! bs2) ns2))])])])]))

    (define (bs/commit! bs)
      ;; bs -> bs
      ;; effect on part of bs
      (cond [(equal? '(commit-point) (car bs))
             (cdr bs)]
            [else
             (let* ([pair (car bs)]
                    [id (car pair)]
                    [ls (cdr pair)])
               (id/commit! id ls)
               (bs/commit! (cdr bs)))]))

    (define (id/commit! id ls)
      ;; id, ls -> id
      ;; effect on id
      (let ()
        (vector-set! id (append ls (vector-ref id 1)))
        id))
    #+end_src

*** apply/cedent

    #+begin_src scheme
    (define (apply/cedent c e)
      ;; cedent, env -> env
      (match c
        ['() e]
        [(h . r) (apply/cedent r (apply/dispatch h e))]))
    #+end_src

*** apply/dispatch

    #+begin_src scheme
    (define (apply/dispatch f e)
      ;; form, env -> env
      (match f
        [('var v) (apply/var v e)]
        [('name n) (apply/name n e)]
        [('arrow a) (apply/literal-arrow a e)]
        [('bind b) (apply/bind b e)]))
    #+end_src

*** apply/literal-arrow

*** apply/var

*** apply/name

*** id->ls

    #+begin_src scheme
    (define (id->ls id)
      (vector-ref id 1))
    #+end_src

* unify

*** >< unify

    #+begin_src scheme
    (define (unify e)
      ;; (env -> env), env -> unify-report
      )
    #+end_src

* >< eva

* >< check

* >< type-apply

* >< sequent

* test

*** natural

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (ap (->
           zero succ
           zero succ succ
           add))

      (ap (->
           zero succ succ
           zero succ succ
           mul))

      (ap (-> mul)))
    #+end_src

*** list

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt list ((:t : type) :t -> type)
          null (-> :t list)
          cons (:t list :t -> :t list))

      ;; (df map (:t1 list (:t1 -> :t2) -> :t2 list)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:t list :t list -> :t1 list)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src

*** vector

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt vector ((:t : type) natural :t -> type)
          null (-> zero :t vector)
          cons (:n :t vector :t -> :n succ :t vector))

      ;; (df map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:m :t vector :n :t vector -> :m :n add :t vector)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src
