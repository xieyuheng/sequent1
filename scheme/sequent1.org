+ sequent calculus as dependent type system of functional language

+ a prototype interpreter

+ XIE Yuheng created

#+PROPERTY: tangle sequent1.scm

* todo

* note

*** formal-form

    - formal-arrow = (formal-cedent formal-cedent)
    - formal-cedent = (formal-form ...)
    - formal-form =
      - ('v formal-var)
      - ('n formal-name)
      - ('a formal-arrow)
      - ('b formal-bind)
    - formal-var = (symbol level)
    - formal-name = symbol
    - formal-bind = ((formal-var ...) formal-cedent leave?)
    - level = natural-number

*** form

    - arrow = (cedent cedent)
    - cedent = (form ...)
    - form =
      - ('var var)
      - ('name name)
      - ('arrow arrow)
      - ('bind bind)
    - var = (id level)
    - name = symbol
    - bind = ((var ...) cedent leave?)
    - id = #(symbol ls)

*** env

    - env = (ds bs ns)
    - ds = (data ...)
    - bs = ((id . ls) ...)
      - ls = ((level . data) ...)
    - ns = ((name . function) ...)

*** data

    - data =
      - ('var var)
      - ('cons (name (data ...)))
      - ('trunk (function (arrow ...) (data ...)))

*** function

    - function =
      - ('normal-function normal-function)
      - ('type-constructor type-constructor)
      - ('data-constructor data-constructor)
    - normal-function = (formal-arrow arity (formal-arrow ...))
    - type-constructor = (formal-arrow arity (name ...))
    - data-constructor = (formal-arrow arity name)
    - arity = (number number)

*** top

    - top =
      - ('dt type-definition)
      - ('df function-definition)
      - ('ap formal-arrow)
    - type-definition =
      ((formal-name formal-arrow) ((formal-name formal-arrow) ...))
    - function-definition =
      ((formal-name formal-arrow) (formal-arrow ...))

*** unify-report

    - unify-report =
      - ('fail (report ...))
      - ('success (report ...) env)
    - report = ?

* helper

*** pattern match

    #+begin_src scheme
    ;; module system of guile
    ;; using http://synthcode.com/scheme/match.scm
    (use-modules (ice-9 match))

    (define-syntax pam
      (syntax-rules ()
        [(pam v (p e ...) ...)
         (match v (p (pam-one e) ...) ...)]))

    (define-syntax pam-one
      (syntax-rules (quote)
        [(_ ((quote s) b ...)) (list (quote s) (pam-one b) ...)]
        [(_ (f b ...)) (f (pam-one b) ...)]
        [(_ e) e]))

    (pam '(a b c)
      [('a 'b . _) ('d ('k))])
    #+end_src

*** cat & orz

    #+begin_src scheme
    (define-syntax cat
      (syntax-rules ()
        [(cat (str . args))
         (format str . args)]
        [(cat (str . args) (str2 . args2) ...)
         (string-append
          (cat (str . args))
          (cat (str2 . args2) ...))]))

    (define-syntax orz
      (syntax-rules ()
        [(orz . body)
         (error (cat . body))]))

    (define-syntax note
      (syntax-rules ()
        [(note . body)
         (void)]))
    #+end_src

*** >< list

    #+begin_src scheme

    #+end_src

*** >< string

    #+begin_src scheme

    #+end_src

* >< parse

*** ><

    #+begin_src scheme

    #+end_src

* >< pass1

*** ><

    #+begin_src scheme

    #+end_src

* >< apply

*** ><

    #+begin_src scheme

    #+end_src

* >< unify

*** ><

    #+begin_src scheme

    #+end_src

* >< eva

* >< check

* >< sequent

* test

*** natural

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (ap (->
           zero succ
           zero succ succ
           add))

      (ap (->
           zero succ succ
           zero succ succ
           mul))

      (ap (-> mul)))
    #+end_src

*** list

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt list ((:t :> type) :t -> type)
          null (-> :t list)
          cons (:t list :t -> :t list))

      ;; (df map (:t1 list (:t1 -> :t2) -> :t2 list)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:t list :t list -> :t1 list)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src

*** vector

    #+begin_src scheme :tangle no
    (sequent

      (dt type (-> type))

      (dt natural (-> type)
          zero (-> natural)
          succ (natural -> natural))

      (df add (natural natural -> natural)
          (:m zero -> :m)
          (:m :n succ -> :m :n add succ))

      (df mul (natural natural -> natural)
          (:m zero -> zero)
          (:m :n succ -> :m :n mul :m add))

      (dt vector ((:t :> type) natural :t -> type)
          null (-> zero :t vector)
          cons (:n :t vector :t -> :n succ :t vector))

      ;; (df map (:n :t1 vector (:t1 -> :t2) -> :n :t2 vector)
      ;;     (null :f -> null)
      ;;     (:l :e cons :f -> :e :f apply :l :f map cons))

      (df append (:m :t vector :n :t vector -> :m :n add :t vector)
          (:l null -> :l)
          (:l :r :e cons -> :l :r append :e cons))

      (ap (->
           null
           zero cons
           zero cons
           zero cons
           null
           zero cons
           zero cons
           zero cons
           append)))
    #+end_src
