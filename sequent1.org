#+HTML_HEAD: <link rel="stylesheet" href="asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle sequent1.scm
#+title: sequent1

---------

- a prototype interpreter for a lovely functional language
  which uses sequent calculus as dependent type system

- sequent is called arrow here
  which is the core data type of the language

- as a prototype implementation its unsatisfactory features are
  1. call-by-name
  2. using copy to handle scope

- source code is here https://github.com/xieyuheng/sequent1

- XIE Yuheng created

---------

* todo

  - add type of var at runtime
    - when apply a var
      need to get the type of it
      to form a trunk

  - the structure of trunk need to be redesigned
    to make it possible to substitute lambda into it by var

  - export apply to sequent1
    apply must be handled in pass3

  - test about apply and map

  - design more test to cover all the tricks

  - check-cover

  - check-recur

  - make the sequent/repl more useful then macro in scheme
    - when the program writing in sequent1 is wrong
      sequent1 should handle it instead of crashing

* note

*** form1

    - reduction strategy is revealed by the postfix notation

    #+begin_src scheme :tangle no
    (type form1
      (type form1/var
        (example
          :var
          :var^n))
      (type form1/name
        symbol)
      (type form1/arrow
        '(form1 ... -> form1 ...))
      (type form1/lambda
        '(lambda form1/arrow
           form1/arrow
           ...))
      (type form1/im-bind
        '(form1/var ... : form1 ...))
      (type form1/ex-bind
        '(form1/var ... @ form1 ...)))
    #+end_src

*** form2

    #+begin_src scheme :tangle no
    (type form2
      {'form2/var    {symbol level}}
      {'form2/name   symbol}
      {'form2/arrow  {{form2 ...} {form2 ...}}}
      {'form2/lambda {form2/arrow {form2/arrow ...}}}
      {'form2/bind   {{form2/var ...} {form2 ...} leave?}})
    (type level natural-number)
    (type leave? bool)
    #+end_src

*** form3

    #+begin_src scheme :tangle no
    (type form3
      {'form3/var    {id level}}
      {'form3/name   symbol}
      {'form3/arrow  {{form3 ...} {form3 ...}}}
      {'form3/lambda {form3/arrow {form3/arrow ...}}}
      {'form3/bind   {{form3/var ...} {form3 ...} leave?}})
    (type id #((name . counter) ls))
    #+end_src

*** data

    #+begin_src scheme :tangle no
    (type data
      {'var    {id level}}
      {'cons   {name {data ...}}}
      {'arrow  {cedent cedent}}
      {'lambda {arrow {arrow ...}}}
      {'trunk  {arrow (or name {arrow ...}) {data ...} index}})
    (type cedent {data ...}
          [reverse a cedent get data-list])
    #+end_src

*** env

    #+begin_src scheme :tangle no
    (type env {ds bs ns})
    (type ds {data ...})
    (type bs {(id . ls) ...})
    (type ns {(name . meaning) ...})
    (type ls {(level . data) ...})
    (type meaning
      {'cons/type {arrow name {name ...}}}
      {'cons/data {arrow name name}}
      {'lambda    {arrow {arrow ...}}})
    #+end_src

*** report

    #+begin_src scheme :tangle no
    (type report
      {'fail {info ...}}
      {'success env})
    (type info <free>)
    #+end_src

*** top

    #+begin_src scheme :tangle no
    (type top
      {'deftype {{form1/name form1/arrow} {{form1/name form1/arrow} ...}}}
      {'defn {{form1/name form1/arrow} {form1/arrow ...}}}
      {'app form1/arrow})
    #+end_src

*** no dependent type in scheme

    - because I am not documenting these scheme code by dependent type
      the type document already fail to express
      most of the natural of env passing functions

* pass1

*** note

    - form1 -pass1-> form2
      default-level of var is handled here

*** pass1/arrow

    #+begin_src scheme
    (define (pass1/arrow default-level s)
      (: default-level form1/arrow -> form2/arrow)
      (list (pass1/cedent default-level (left-of '-> s))
            (pass1/cedent default-level (right-of '-> s))))
    #+end_src

*** pass1/cedent

    #+begin_src scheme
    (define (pass1/cedent default-level s)
      (: default-level (form1 ...) -> (form2 ...))
      (match s
        [{} {}]
        [(h . r) (cons (pass1 default-level h)
                       (pass1/cedent default-level r))]))
    #+end_src

*** predicates

    #+begin_src scheme
    (define (form1/var? v)
      (and (symbol? v)
           (equal? ":" (substring (symbol->string v) 0 1))))

    (define (form1/name? v)
      (and (symbol? v)
           (not (eq? ":" (substring (symbol->string v) 0 1)))))

    (define (form1/arrow? v)
      (and (list? v)
           (member '-> v)))

    (define (form1/lambda? v)
      (and (list? v)
           (eq? (car v) 'lambda)))

    (define (form1/im-bind? v)
      (and (list? v)
           (member ': v)))

    (define (form1/ex-bind? v)
      (and (list? v)
           (member '@ v)))
    #+end_src

*** pass1

    #+begin_src scheme
    (define (pass1 default-level v)
      (: default-level form1 -> form2)
      (cond [(form1/var? v)
             (list 'form2/var
                   (pass1/var default-level v))]
            [(form1/name? v)
             (list 'form2/name
                   v)]
            [(form1/arrow? v)
             (list 'form2/arrow
                   (pass1/arrow default-level v))]
            [(form1/lambda? v)
             (list 'form2/lambda
                   (list (pass1/arrow default-level (cadr v))
                         (map (lambda (x) (pass1/arrow default-level x))
                           (cddr v))))]
            [(form1/im-bind? v)
             (list 'form2/bind
                   (list (pass1/cedent 1 (left-of ': v))
                         (pass1/cedent 0 (right-of ': v))
                         #f))]
            [(form1/ex-bind? v)
             (list 'form2/bind
                   (list (pass1/cedent 1 (left-of '@ v))
                         (pass1/cedent 0 (right-of '@ v))
                         #t))]
            [else
             (orz 'pass1 ("pass1 can not handle sexp-form:~a" v))]))
    #+end_src

*** pass1/var

    #+begin_src scheme
    (define (pass1/var default-level v)
      (: default-level symbol -> form2/var)
      (let* ([str (symbol->string v)]
             [cursor (find-char "^" str)])
        (if cursor
          (list (string->symbol (substring str 0 cursor))
                (string->number (substring str (+ 1 cursor) (string-length str))))
          (list v default-level))))
    #+end_src

* pass2

*** note

    - form2 -pass2-> form3
      id of var is handled here

*** pass2/arrow

    #+begin_src scheme
    (define (pass2/arrow a s)
      (: form2/arrow scope -> (form3/arrow scope))
      (match a
        [{ac sc}
         (match (pass2/cedent ac s)
           [{ac1 s1}
            (match (pass2/cedent sc s1)
              [{sc1 s2}
               {{ac1 sc1} s2}])])]))
    #+end_src

*** pass2/cedent

    #+begin_src scheme
    (define (pass2/cedent c s)
      (: (form2 ...) scope -> ((form3 ...) scope))
      (match c
        [{} {{} s}]
        [(f . r)
         (match (pass2 f s)
           [{f1 s1}
            (match (pass2/cedent r s1)
              [{c1 s2}
               {(cons f1 c1) s2}])])]))
    #+end_src

*** pass2/lambda

    #+begin_src scheme
    (define (pass2/lambda l s)
      (: form2/lambda scope -> (form3/lambda scope))
      (match l
        [{a al}
         {{(pass2/arrow a s)
           (map (lambda (x) (pass2/arrow x s))
             al)}
          s}]))
    #+end_src

*** pass2

    #+begin_src scheme
    (define (pass2 f s)
      (: form2 scope -> (form2 scope))
      (match f
        [{'form2/var v}
         (match (pass2/var v s)
           [{v1 s1}
            {{'form3/var v1} s1}])]
        [{'form2/name n}
         {{'form3/name n} s}]
        [{'form2/arrow a}
         (match (pass2/arrow a s)
           [{a1 s1}
            {{'form3/arrow a1} s1}])]
        [{'form2/lambda l}
         (match (pass2/lambda l s)
           [{l1 s1}
            {{'form3/lambda l1} s1}])]
        [{'form2/bind b}
         (match (pass2/bind b s)
           [{b1 s1}
            {{'form3/bind b1} s1}])]))
    #+end_src

*** pass2/var

    #+begin_src scheme
    (define id/counter 0)

    (define (pass2/var v s)
      (: form2/var scope -> (form3/var scope))
      (match v
        [{symbol level}
         (let ([found (assq symbol s)])
           (if found
             (let ([old (cdr found)])
               {{old level} s})
             (let ([new (vector (cons symbol id/counter) '())])
               (set! id/counter (+ 1 id/counter))
               {{new level}
                (cons (cons symbol new) s)})))]))
    #+end_src

*** pass2/bind

    #+begin_src scheme
    (define (pass2/bind b s)
      (: form2/bind scope -> (form3/bind scope))
      (match b
        [{vs c leave?}
         (match (pass2/cedent vs s)
           [{vs1 s1}
            (match (pass2/cedent c s1)
              ;; this means vars in vs can occur in c
              [{c1 s2}
               {{vs1 c1 leave?} s2}])])]))
    #+end_src

* pass3

*** note

    - form3 -pass3-> data
      cons & trunk are created here

    - note that
      we are building new function body
      with the help of the data-stack
      thus
      whenever a list of data in data-stack are used to form a function body
      the list should be reversed

    - pass3 will use env passing
      note that
      when env passing is used
      those functions would not be separately testable

    - no unification here
      bs is not used here
      bind just effect on the id of var

    - ns is searched
      but no effect on ns

    - how should I express such in type and prove them ?

    - when meet 'apply' form a trunk from arrow or lambda
      if it is arrow
      use infer/arrow to get the type of it
      if it is lambda
      use infer/arrow-list to get the type of it

    - note that
      nested arrow or lambda will not block scope
      different var must have different name
      this is due to the natural of non-determinate data

*** env/pop

    #+begin_src scheme
    (define (env/pop e)
      (: env -> (data env))
      (match e
        [{(d . r) bs ns}
         {d {r bs ns}}]))
    #+end_src

*** pass3/get-arrow

    #+begin_src scheme
    (define (pass3/get-arrow a e)
      (: form3/arrow env -> arrow)
      (match (env/pop (pass3/arrow a e))
        [{{'arrow arrow} __}
         arrow]))
    #+end_src

*** pass3/arrow

    #+begin_src scheme
    (define (pass3/arrow a e)
      (: form3/arrow env -> env)
      (match e
        [{ds bs ns}
         (match a
           [{ac sc}
            (match (pass3/cedent ac e)
              [{ds1 __ __}
               (match (pass3/cedent sc e)
                 [{ds2 __ __}
                  {(cons {'arrow {(reverse ds1) (reverse ds2)}}
                         ds)
                   bs
                   ns}])])])]))
    #+end_src

*** pass3/cedent

    #+begin_src scheme
    (define (pass3/cedent c e)
      (: (form3 ...) env -> env)
      (match e
        [{ds bs ns}
         (match c
           [{} e]
           [(h . r) (pass3/cedent r (pass3 h e))])]))
    #+end_src

*** pass3/lambda

    #+begin_src scheme
    (define (pass3/lambda l e)
      (: form3/lambda env -> env)
      (match e
        [{ds bs ns}
         (match l
           [{a al}
            {(cons {'lambda (pass3/get-arrow a e)
                     (map (lambda (x)
                            (pass3/get-arrow x e))
                       al)}
                   ds)
             bs
             ns}])]))
    #+end_src

*** pass3

    #+begin_src scheme
    (define (pass3 f e)
      (: form3 env -> env)
      (match f
        [{'form3/var x} (pass3/var x e)]
        [{'form3/name 'apply} (pass3/apply e)]
        [{'form3/name x} (pass3/name x e)]
        [{'form3/arrow x} (pass3/arrow x e)]
        [{'form3/lambda x} (pass3/lambda x e)]
        [{'form3/bind x} (pass3/bind x e)]))
    #+end_src

*** pass3/var

    #+begin_src scheme
    (define (pass3/var v e)
      (: form3/var env -> env)
      (match e
        [{ds bs ns}
         ;; actually there is no need to search bs
         ;; but anyway
         {(cons (bs/deep bs {'var v}) ds)
          bs
          ns}]))
    #+end_src

*** pass3/apply

    #+begin_src scheme
    (define (pass3/apply e)
      (: env -> env)
      (match e
        [{(d . r) bs ns}
         (match d
           [{'arrow a}
            (pass3/apply/arrow d {r bs ns})]
           [{'lambda l}
            (pass3/apply/lambda l {r bs ns})]
           [__
            (orz 'pass3/apply
              ("can only apply arrow or lambda~%")
              ("but the data at the top of data-stack is : ~a~%" d))])]))
    #+end_src

*** >< pass3/apply/arrow

    #+begin_src scheme
    (define (pass3/apply/arrow a e)
      (: arrow env -> env)
      (match e
        [{ds bs ns}
         (let* ([t (infer/arrow a e)])
           (match t
             [{ac sc}
              (let* ([alen (length ac)]
                     [slen (length sc)]
                     [dl (sublist ds 0 alen)]
                     [make-trunk (lambda (i) {'trunk {t {a} dl i}})])
                {(append (map make-trunk (genlist slen))
                         (sublist ds alen (length ds)))
                 bs
                 ns})]))]))
    #+end_src

*** >< pass3/apply/lambda

    #+begin_src scheme
    (define (pass3/apply/lambda l e)
      (: lambda env -> env)
      (match e
        [{ds bs ns}
         (match l
           [{{ac sc} al}
            (let* ([alen (length ac)]
                   [slen (length sc)]
                   [dl (sublist ds 0 alen)]
                   [make-trunk (lambda (i) {'trunk {{ac sc} al dl i}})])
              {(append (map make-trunk (genlist slen))
                       (sublist ds alen (length ds)))
               bs
               ns})])]))
    #+end_src

*** id->name & id->counter & id->ls

    #+begin_src scheme
    (define (id->name id)
      (car (vector-ref id 0)))

    (define (id->counter id)
      (cdr (vector-ref id 0)))

    (define (id->ls id)
      (vector-ref id 1))
    #+end_src

*** pass3/name

    - this can be optimized by
      to do more computations before storing things into ns
      but I leave it for now

    #+begin_src scheme
    (define (pass3/name n e)
      (: form3/name env -> env)
      (match e
        [{ds bs ns}
         (let ([found (assq n ns)])
           (if (not found)
             (orz 'pass3/name ("unknow name : ~a~%" n))
             (let ([meaning (cdr found)])
               (match meaning
                 [{'cons/type {{ac sc} n1 __}}
                  (pass3/name/cons (length ac) n1 e)]
                 [{'cons/data {{ac sc} n1 __}}
                  (pass3/name/cons (length ac) n1 e)]
                 [{'lambda {{ac sc} __}}
                  (pass3/name/trunk (length ac) (length sc) {ac sc} n e)]))))]))
    #+end_src

*** pass3/name/cons

    #+begin_src scheme
    (define (pass3/name/cons len name e)
      (: length name env -> env)
      (match e
        [{ds bs ns}
         {(cons {'cons
                 ;; dl in cons is as the order of dl in start
                 ;; thus no reverse is needed
                 {name (sublist ds 0 len)}}
                (sublist ds len (length ds)))
          bs
          ns}]))
    #+end_src

*** pass3/name/trunk

    - when intro a trunk from name
      only name should be recorded not the body
      this is to handle recursive definitions

    - type arrow needs to be copied

    #+begin_src scheme
    (define (pass3/name/trunk alen slen a n e)
      (: length length arrow name env -> env)
      (match e
        [{ds bs ns}
         (let* ([a (copy-arrow a)]
                [dl (sublist ds 0 alen)]
                ;; dl in trunk is as the order of dl in stack
                ;; thus no reverse is needed
                [make-trunk (lambda (i) {'trunk {a n dl i}})])
           {(append (map make-trunk (genlist slen))
                    (sublist ds alen (length ds)))
            bs
            ns})]))
    #+end_src

*** ><><>< pass3/bind

    #+begin_src scheme
    (define (pass3/bind b e)
      (: form3/bind env -> env)
      (match b
        [{vl c leave?}
         (match (pass3/cedent c e)
           ;; ><><><
           ;; here I assume the c returns only one data
           ;; actual error handling is needed
           [{(d1 . __) __ __}
            (letrec ([recur
                      ;; (: (form3/var ...) env -> env)
                      (lambda (vl e)
                        (match e
                          [{ds bs ns}
                           (match vl
                             [{} e]
                             [({'form3/var {id level}} . r)
                              ;; ><><><
                              ;; no error handling here
                              ;; ><><><
                              ;; need to check if the bind already exist
                              ;; and to check type
                              (id/commit! id {(cons level d1)})
                              (recur r {(if leave?
                                          (cons d1 ds)
                                          ds)
                                        bs
                                        ns})])]))])
              (recur vl e))])]))
    #+end_src

*** id/commit!

    #+begin_src scheme
    (define (id/commit! id ls)
      (: id ls -> id
         [with effect on id])
      (let ()
        (vector-set! id 1 (append ls (vector-ref id 1)))
        id))
    #+end_src

* bind-stack

*** note

    - ><><><

    - infer level n can get level n+1

    - note how the types of these functions are different

*** bs/find

    #+begin_src scheme
    (define (bs/find bs v)
      (: bs var -> (or data #f))
      (match v
        [{id level}
         (let* ([level (if (eq? level #f)
                         0
                         level)]
                [found/commit (assq level (id->ls id))])
           (if found/commit
             (cdr found/commit)
             (let* ([found/ls (assq id bs)]
                    [found/bind
                     (if found/ls
                       (assq level (cdr found/ls))
                       #f)])
               (if found/bind
                 (cdr found/bind)
                 #f))))]))
    #+end_src

*** bs/walk

    #+begin_src scheme
    (define (bs/walk bs d)
      (: bs data -> data)
      (match d
        [{'var v}
         (let ([found (bs/find bs v)])
           (if found
             (bs/walk bs found)
             d))]
        [{__ e} d]))
    #+end_src

*** bs/deep

    - do not handle trunk here
      because I think maybe no computations should be done in pass3

    #+begin_src scheme
    (define (bs/deep bs d)
      (: bs data -> data)
      (letrec* ([bs/deep-list
                 (lambda (bs dl)
                   (map (lambda (x) (bs/deep bs x)) dl))]
                [bs/deep-arrow
                 (lambda (bs a)
                   (match a
                     [(dl1 dl2)
                      (list (bs/deep-list bs dl1)
                            (bs/deep-list bs dl2))]))]
                [bs/deep-arrow-list
                 (lambda (bs al)
                   (map (lambda (a) (bs/deep-arrow bs a)) al))])
        (match (bs/walk bs d)
          [{'var v}
           {'var v}]
          [{'cons (name dl)}
           {'cons {name (bs/deep-list bs dl)}}]
          [{'arrow a} {'arrow (bs/deep-arrow bs a)}]
          [{'lambda (a al)}
           {'lambda {(bs/deep-arrow bs a)
                     (bs/deep-arrow-list bs al)}}]
          [{'trunk (a al dl i)}
           {'trunk
             {(bs/deep-arrow bs a)
              (if (symbol? al)
                al
                (bs/deep-arrow-list bs al))
              (bs/deep-list bs dl)
              i}}])))
    #+end_src

* copy-arrow

*** note

    - the name in trunk will be changed to (arrow ...)
      (arrow ...) is fetched from ns and copied

    - copy-arrow is called when
      | trunk intro in pass3          | copy type arrow                    |
      | trunk->trunk*                 | copy body arrow-list               |
      | compute/arrow in type-compute | copy arrow to maintain undo-ablity |

    - copy is arrow by arrow
      every var in new arrow is different from old arrow
      thus
      1. scope is also arrow by arrow
      2. a non-determinate var can not be substituted into lambda as it is
         but is copied

    - this copy is one of the main place where this prototype can be optimized
      a vm can be designed to replace this copy function
      and change the interpreter to a compiler

*** copy-arrow

    #+begin_src scheme
    (define (copy-arrow a)
      (: arrow -> arrow)
      (match (copy/arrow a '())
        [{a s} a]))
    #+end_src

*** copy/arrow

    #+begin_src scheme
    (define (copy/arrow a s)
      (: arrow scope -> (arrow scope))
      (match a
        [{ac sc}
         (match (copy/cedent ac s)
           [{ac1 s1}
            (match (copy/cedent sc s1)
              [{sc1 s2}
               {{ac1 sc1} s2}])])]))
    #+end_src

*** copy/data-list

    #+begin_src scheme
    (define (copy/data-list dl s)
      (: (data ...) scope -> ((data ...) scope))
      (copy/cedent dl s))
    #+end_src

*** copy/cedent

    #+begin_src scheme
    (define (copy/cedent c s)
      (: cedent scope -> (cedent scope))
      (match c
        [{} {{} s}]
        [(h . r)
         (match (copy h s)
           [{h1 s1}
            (match (copy/cedent r s1)
              [{r1 s2}
               {(cons h1 r1) s2}])])]))
    #+end_src

*** copy/lambda

    #+begin_src scheme
    (define (copy/lambda l s)
      (: lambda scope -> (lambda scope))
      (match l
        [{a al}
         (match (copy/arrow a s)
           [{a1 s1}
            (match (copy/arrow-list al s1)
              [{al1 s2}
               {{a1 al1} s2}])])]))
    #+end_src

*** copy/arrow-list

    #+begin_src scheme
    (define (copy/arrow-list al s)
      (: (arrow ...) scope -> ((arrow ...) scope))
      (match al
        [{} {{} s}]
        [(h . r)
         (match (copy/arrow h s)
           [{h1 s1}
            (match (copy/arrow-list r s1)
              [{r1 s2}
               {(cons h1 r1) s2}])])]))
    #+end_src

*** copy

    #+begin_src scheme
    (define (copy d s)
      (: data scope -> (data scope))
      (match d
        [{'var x}
         (match (copy/var x s)
           [{x1 s1}
            {{'var x1} s1}])]
        [{'cons x}
         (match (copy/cons x s)
           [{x1 s1}
            {{'cons x1} s1}])]
        [{'arrow x}
         (match (copy/arrow x s)
           [{x1 s1}
            {{'arrow x1} s1}])]
        [{'lambda x}
         (match (copy/lambda x s)
           [{x1 s1}
            {{'lambda x1} s1}])]
        [{'trunk x}
         (match (copy/trunk x s)
           [{x1 s1}
            {{'trunk x1} s1}])]))
    #+end_src

*** copy/var

    #+begin_src scheme
    (define (copy/var v s)
      (: var scope -> (var scope))
      (match v
        [{id level}
         (let ([found (assq id s)])
           (if found
             {{(cdr found) level} s}
             (let* ([ls (id->ls id)]
                    [id1 (vector (cons (id->name id) id/counter) '())]
                    [s1 (cons (cons id id1) s)])
               (set! id/counter (+ 1 id/counter))
               (match (copy/ls ls s1)
                 [{ls1 s2}
                  (id/commit! id1 ls1)
                  {{id1 level} s2}]))))]))
    #+end_src

*** copy/ls

    #+begin_src scheme
    (define (copy/ls ls s)
      (: ls scope -> (ls scope))
      (match ls
        [{} {{} s}]
        [((level . data) . r)
         (match (copy data s)
           [{data1 s1}
            (match (copy/ls r s1)
              [{r1 s2}
               {(cons (cons level data1)
                      r1)
                s2}])])]))
    #+end_src

*** copy/cons

    #+begin_src scheme
    (define (copy/cons c s)
      (: cons scope -> (cons scope))
      (match c
        [{n dl}
         (match (copy/data-list dl s)
           [{dl1 s1}
            {{n dl1} s1}])]))
    #+end_src

*** copy/trunk

    #+begin_src scheme
    (define (copy/trunk p s)
      (: trunk scope -> (trunk scope))
      (match p
        [{a al dl i}
         (if (symbol? al)
           (match (copy/arrow a s)
             [{a1 s1}
              (match (copy/data-list dl s1)
                [{dl1 s2}
                 {{a1 al dl1 i} s2}])])
           (match (copy/arrow a s)
             [{a1 s1}
              (match (copy/arrow-list al s1)
                [{al1 s2}
                 (match (copy/data-list dl s2)
                   [{dl1 s3}
                    {{a1 al1 dl1 i} s3}])])]))]))
    #+end_src

* compute

*** compute/arrow

    - commit should be preformed arrow by arrow
      one arrow can only commit on its own var
      this is achieve by the natural of the structure of bs

    - note that
      commit is only meant to handle non-determinate var
      of which the level n is bound
      where n > 0

    #+begin_src scheme
    (define (compute/arrow a e)
      (: arrow env -> report)
      (match e
        [{ds bs ns}
         (match a
           [{ac sc}
            (let ([alen (length ac)]
                  [slen (length sc)])
              (match (compute/cedent ac {ds (cons '(commit-point) bs) ns})
                [{'fail il} {'fail il}]
                [{'success {ds1 bs1 ns1}}
                 (match (unify/data-list
                         (take ds1 alen) (take (drop ds1 alen) alen)
                         {'success
                          {(drop (drop ds1 alen) alen)
                           bs1
                           ns1}})
                   [{'fail il} {'fail il}]
                   [{'success e2}
                    (match (compute/cedent sc e2)
                      [{'fail il} {'fail il}]
                      [{'success {ds3 bs3 ns3}}
                       {'success {ds3 (bs/commit! bs3) ns3}}])])]))])]))
    #+end_src

*** bs/commit!

    #+begin_src scheme
    (define (bs/commit! bs)
      (: bs -> bs
         [with effect on part of elements of bs])
      (cond [(equal? '(commit-point) (car bs))
             (cdr bs)]
            [else
             (let* ([pair (car bs)]
                    [id (car pair)]
                    [ls (cdr pair)])
               (id/commit! id ls)
               (bs/commit! (cdr bs)))]))
    #+end_src

*** compute/cedent

    #+begin_src scheme
    (define (compute/cedent c e)
      (: cedent env -> report)
      (match c
        [{} {'success e}]
        [(h . r)
         (match (compute h e)
           [{'fail il} {'fail il}]
           [{'success e1} (compute/cedent r e1)])]))
    #+end_src

*** compute

    #+begin_src scheme
    (define (compute d e)
      (: data env -> report)
      (match e
        [(ds bs ns)
         (match d
           [{'var x} (compute/var x e)]
           [{'cons x} (compute/cons x e)]
           [{'trunk x} (compute/trunk x e)]
           [__ {'success {(cons d ds) bs ns}}])]))
    #+end_src

*** compute/var

    #+begin_src scheme
    (define (compute/var v e)
      (: var env -> report)
      (match e
        [(ds bs ns)
         (let ([d (bs/deep bs {'var v})])
           (match d
             ;; result found from this var needs to be compute again
             ;; except for fresh var
             [{'var __}
              {'success {(cons d ds) bs ns}}]
             [{__ __}
              (compute d e)]))]))
    #+end_src

*** compute/cons

    #+begin_src scheme
    (define (compute/cons c e)
      (: cons env -> report)
      (match e
        [(ds bs ns)
         (match c
           [(n dl)
            ;; the following reverse
            ;; dl in stack -> dl in function body
            (match (compute/cedent (reverse dl) (list '() bs ns))
              [{'fail il}
               {'fail (cons `(compute/cons
                              fail
                              (cons: ,c))
                            il)}]
              [{'success {ds1 bs1 ns1}}
               {'success {(cons {'cons {n ds1}}
                                ds)
                          bs
                          ns}}])])]))
    #+end_src

*** trunk->trunk*

    - replace the name in trunk by arrow-list

    - the ns of env is needed
      to find the arrow-list under the name

    #+begin_src scheme
    (define (trunk->trunk* t e)
      (: trunk env -> trunk)
      (match e
        [{ds bs ns}
         (match t
           [{a al dl i}
            (if (not (symbol? al))
              {a al dl i}
              ;; this is the only place (arrow ...) is copied
              ;; ><><>< many place are copying now
              (let* ([n al]
                     [found (assq n ns)])
                (if (not found)
                  (orz 'trunk->trunk*
                    ("fail~%")
                    ("unknow name : ~a~%" n))
                  (let ([meaning (cdr found)])
                    (match meaning
                      [{'lambda {{ac sc} al1}}
                       {a (map copy-arrow al1) dl i}]
                      [__
                       (orz 'trunk->trunk*
                         ("trunk->trunk* fail~%" )
                         ("name is not lambda : ~a~%" n))])))))])]))
    #+end_src

*** compute/trunk

    - there is no reducible trunk after compute/trunk
      thus no reducible trunk after compute/arrow
      ><><><
      but it is actually not true
      because computations after a non-reducible trunk
      might make the trunk reducible
      but no look-back is implemented to handle such case

    #+begin_src scheme
    (define (compute/trunk t e)
      (: trunk env -> report)
      (match e
        [{ds bs ns}
         (match (trunk->trunk* t e)
           [{a al dl i}
            ;; the following reverse
            ;; dl in stack -> dl in function body
            (match (compute/cedent (reverse dl) {{} bs ns})
              [{'fail il}
               {'fail (cons `(compute/trunk
                              fail when computing data-list
                              (data-list: ,dl)
                              (cons: ,c))
                            il)}]
              [{'success e1}
               (match e1
                 [{ds1 bs1 ns1}
                  (let* ([dl1 ds1]
                         [al1 (filter-arrow-list al dl1 e1)])
                    (match al1
                      [{}
                       {'fail {`(compute/trunk
                                 no antecedent match
                                 (data-list: ,ds1)
                                 (arrow-list: ,al)
                                 (trunk: ,t))}}]
                      [{a1}
                       (match (compute/arrow a1 e1)
                         ;; after this compute/arrow
                         ;; binds are commited
                         [{'success e2}
                          {'success {(cons (proj i e2) ds)
                                     bs1
                                     ns1}}]
                         [{'fail il} {'fail il}])]
                      [(a1 a2 . __)
                       {'success
                        {(cons {'trunk {a al1 dl1 i}}
                               ds)
                         bs1
                         ns1}}]))])])])]))
    #+end_src

*** filter-arrow-list

    - no commit should be made here

    #+begin_src scheme
    (define (filter-arrow-list al dl e)
      (: (arrow ...) (data ...) env -> (arrow ...))
      (if (eq? '() al)
        '()
        (match e
          [{ds bs ns}
           (match (car al)
             [{ac __}
              (let ([alen (length ac)])
                (match (compute/cedent ac e)
                  [{'fail __}
                   (orz 'filter-arrow-list ("fail to compute/cedent~%"))]
                  [{'success {ds1 bs1 ns1}}
                   (match (unify/data-list
                           dl (take ds1 alen)
                           {'success {(drop ds1 alen)
                                      bs1
                                      ns1}})
                     [{'fail __}
                      (filter-arrow-list (cdr al) dl e)]
                     [{'success __}
                      (cons (car al)
                            (filter-arrow-list (cdr al) dl e))])]))])])))
    #+end_src

*** proj

    #+begin_src scheme
    (define (proj i e)
      (: index env -> data)
      (match e
        [(ds bs ns)
         (list-ref ds (- (length ds) (+ 1 i)))]))
    #+end_src

* print

*** print/cedent

    #+begin_src scheme
    (define (print/cedent c e)
      (: cedent env -> [effect on terminal])
      (match c
        [{} (void)]
        [{d} (print/data d e)]
        [(d . r)
         (print/data d e)
         (format #t " ")
         (print/cedent r e)]))
    #+end_src

*** print/data-list

    #+begin_src scheme
    (define (print/data-list dl e)
      (: (data ...) env -> [effect on terminal])
      (print/cedent (reverse dl) e))
    #+end_src

*** print/data

    #+begin_src scheme
    (define (print/data d e)
      (: data env -> [effect on terminal])
      (match d
        [{'var x} (print/var x e)]
        [{'cons x} (print/cons x e)]
        [{'arrow x} (print/arrow x e)]
        [{'lambda x} (print/lambda x e)]
        [{'trunk x} (print/trunk x e)]))
    #+end_src

*** print/var

    - different var should be print differently

    - note that
      the env is not used by even print/var

    #+begin_src scheme
    (define (print/var v e)
      (: var env -> [effect on terminal])
      (match v
        [{id level}
         (let ([name (id->name id)]
               [counter (id->counter id)])
           (format #t ":~a:~a^~a" counter name level))]))
    #+end_src

*** print/cons

    #+begin_src scheme
    (define (print/cons c e)
      (: cons env -> [effect on terminal])
      (match c
        [{n dl}
         (format #t "[")
         (print/data-list dl e)
         (if (null? dl)
           (format #t "~a]" n)
           (format #t " ~a]" n))]))
    #+end_src

*** print/arrow

    #+begin_src scheme
    (define (print/arrow a e)
      (: arrow env -> [effect on terminal])
      (match a
        [{ac sc}
         (format #t "(")
         (print/cedent ac e)
         (format #t " -> ")
         (print/cedent sc e)
         (format #t ")")]))
    #+end_src

*** >< print/lambda

    #+begin_src scheme
    (define (print/lambda l e)
      (: lambda env -> [effect on terminal])
      (match l
        [{a al}
         (format #t "<lambda>")]))
    #+end_src

*** >< print/trunk

    #+begin_src scheme
    (define (print/trunk t e)
      (: trunk env -> [effect on terminal])
      (match t
        [{a al dl i}
         (format #t "<trunk>")]))
    #+end_src

* unify

*** note

    - firstly we have first order syntactic unification

    - except for unify/trunk/data
      where semantic unification is used

    - and for unify/trunk
      where first syntactic unification is tried
      if it fail
      semantic unification is used

    - semantic unification is unification modulo theory
      the theory here is function composition

*** unify/data-list

    #+begin_src scheme
    (define (unify/data-list pl dl r)
      (: (pattern ...) (data ...) report -> report)
      (match r
        [{'fail il} {'fail il}]
        [{'success e}
         (cond [(and (eq? pl '()) (eq? dl '()))
                r]
               [(eq? pl {})
                {'fail {`(unify/data-list
                          fail pl and dl is not of the same length
                          (additional-dl: ,dl))}}]
               [(eq? dl {})
                {'fail {`(unify/data-list
                          fail pl and dl is not of the same length
                          (additional-pl: ,pl))}}]
               [else
                (unify/data-list
                 (cdr pl) (cdr dl)
                 (unify/data (car pl) (car dl) e))])]))
    #+end_src

*** var/eq?

    #+begin_src scheme
    (define (var/eq? v1 v2)
      (match (list v1 v2)
        [{{id1 level1} {id2 level2}}
         (and (eq? id1 id2)
              (eq? level1 level2))]))
    #+end_src

*** unify/data

    #+begin_src scheme
    (define (unify/data p d e)
      (: pattern data env -> report)
      (match e
        [{ds bs ns}
         ;; var -walk-> fresh-var
         (let ([p (bs/walk bs p)]
               [d (bs/walk bs d)])
           (match {p d}
             [{{'var v1} {'var v2}}
              (if (var/eq? v1 v2)
                {'success e}
                (unify/var/data v1 d e))]
             [{{'var v} __} (unify/var/data v d e)]
             [{__ {'var v}} (unify/var/data v p e)]

             [{{'trunk t1} {'trunk t2}} (unify/trunk t1 t2 e)]
             [{{'trunk t} __} (unify/trunk/data t d e)]
             [{__ {'trunk t}} (unify/trunk/data t p e)]

             [{{'cons c1} {'cons c2}} (unify/cons c1 c2 e)]
             [{{'arrow a1} {'arrow a2}} (unify/arrow a1 a2 e)]
             [{{'lambda l1} {'lambda l2}} (unify/lambda l1 l2 e)]
             [{__ __}
              {'fail {`(unify/data
                        fail to unify
                        (pattern: ,p) (data: ,d))}}]))]))
    #+end_src

*** bs/extend

    #+begin_src scheme
    (define (bs/extend bs v d)
      (: bs var data -> bs)
      (match v
        [{id level}
         (let ([found/ls (assq id bs)])
           (if found/ls
             (substitute (cons id (cons (cons level d)
                                        (cdr found/ls)))
                         (lambda (pair) (eq? (car pair) id))
                         bs)
             (cons (cons id (list (cons level d)))
                   bs)))]))
    #+end_src

*** unify/var/data

    - before bs/extend need to ensure that
      the bind to be added is consistent with binds already in bs
      this is where the levels of var come into the game

    #+begin_src scheme
    (define (unify/var/data v d e)
      (: fresh-var data env -> report)
      (match e
        [{ds bs ns}
         ;; {'success {ds (bs/extend bs v d) ns}}
         (match (consistent-check v d e)
           [{'fail il} {'fail il}]
           [{'success __}
            {'success {ds (bs/extend bs v d) ns}}])]))
    #+end_src

*** consistent-check

***** consistent-check

      #+begin_src scheme
      (define (consistent-check v d e)
        (: fresh-var data env -> report)
        (match {v e}
          [{{id level} {ds bs ns}}
           (match {(var/highest? v e) (var/lowest? v e)}
             [{#t #t} {'success e}]
             [{#t #f}
              (match (var/below v e)
                [{{__ low-level} low-d}
                 (consistent-check/level-diff (- level low-level) low-d d e)])]
             [{#f #t}
              (match (var/above v e)
                [{{__ high-level} high-d}
                 (consistent-check/level-diff (- high-level level) d high-d e)])]
             [{#f #f}
              (match (var/below v e)
                [{{__ low-level} low-d}
                 (match (consistent-check/level-diff (- level low-level) low-d d e)
                   [{'fail il} {'fail il}]
                   [{'success __}
                    (match (var/above v e)
                      [{{__ high-level} high-d}
                       (consistent-check/level-diff (- high-level level) d high-d e)])])])])]))
      #+end_src

***** consistent-check/level-diff

      #+begin_src scheme
      (define (consistent-check/level-diff level-diff d1 d2 e)
        (: level-diff data data env -> report)
        (match e
          [{ds bs ns}
           (match (type-compute/repeat level-diff d1 e)
             [{'fail il} {'fail il}]
             [{'success {(d0 . __) bs1 ns1}}
              (unify/data d0 d2 {ds bs1 ns1})])]))
      #+end_src

***** type-compute/repeat

      #+begin_src scheme
      (define (type-compute/repeat c d e)
        (: counter data env -> report)
        (match e
          [{ds bs ns}
           (match (eq? 0 c)
             [#t {'success {(cons d ds) bs ns}}]
             [#f (match (type-compute d e)
                   [{'fail il} {'fail il}]
                   [{'success {(d1 . r) bs1 ns1}}
                    (type-compute/repeat (- c 1) d1 {r bs1 ns1})])])]))
      #+end_src

***** var/highest? & var/lowest?

      #+begin_src scheme
      (define (var/highest? v e)
        (: fresh-var env -> bool)
        (match e
          [{ds bs ns}
           (match v
             [{id level}
              (let* ([found (assq id bs)]
                     [ls (append (id->ls id)
                                 (if found (cdr found) '()))])
                (list-every?
                 (lambda (x) (> level (car x)))
                 ls))])]))

      (define (var/lowest? v e)
        (: fresh-var env -> bool)
        (match e
          [{ds bs ns}
           (match v
             [{id level}
              (let* ([found (assq id bs)]
                     [ls (append (id->ls id)
                                 (if found (cdr found) '()))])
                (list-every?
                 (lambda (x) (< level (car x)))
                 ls))])]))
      #+end_src

***** var/above & var/below

      #+begin_src scheme
      (define (var/above v e)
        (: fresh-var env -> (var data))
        (match e
          [{ds bs ns}
           (match v
             [{id level}
              (let* ([found (assq id bs)]
                     [ls (append (id->ls id)
                                 (if found (cdr found) '()))])
                (let ([pair
                       (car (filter (lambda (x) (> (car x) level))
                                    (sort (lambda (x y) (< (car x) (car y)))
                                          ls)))])
                  {{id (car pair)} (cdr pair)}))])]))

      (define (var/below v e)
        (: fresh-var env -> (var data))
        (match e
          [{ds bs ns}
           (match v
             [{id level}
              (let* ([found (assq id bs)]
                     [ls (append (id->ls id)
                                 (if found (cdr found) '()))])
                (let ([pair
                       (car (filter (lambda (x) (< (car x) level))
                                    (sort (lambda (x y) (> (car x) (car y)))
                                          ls)))])
                  {{id (car pair)} (cdr pair)}))])]))
      #+end_src

*** unify/cons

    #+begin_src scheme
    (define (unify/cons c1 c2 e)
      (: cons cons env -> report)
      (match {c1 c2}
        [{{n1 dl1} {n2 dl2}}
         (if (eq? n1 n2)
           (unify/data-list dl1 dl2 {'success e})
           {'fail {`(unify/cons
                     fail
                     (cons1: ,c1)
                     (cons2: ,c2))}})]))
    #+end_src

*** unify/arrow

    #+begin_src scheme
    (define (unify/arrow a1 a2 e)
      (: arrow arrow env -> report)
      (match {a1 a2}
        [{{ac1 sc1} {ac2 sc2}}
         (match (unify/data-list ac1 ac2 {'success e})
           [{'success e1}
            (unify/data-list sc1 sc2 {'success e1})]
           [{'fail il}
            {'fail (cons `(unify/arrow
                           fail  (arrow1: ,a1) (arrow2: ,a2))
                         il)}])]))
    #+end_src

*** unify/lambda

    #+begin_src scheme
    (define (unify/lambda l1 l2 e)
      (: lambda lambda env -> report)
      (match {l1 l2}
        [{{a1 al1} {a2 al2}}
         (unify/arrow-list al1 al2 (unify/arrow a1 a2 e))]))
    #+end_src

*** unify/arrow-list

    #+begin_src scheme
    (define (unify/arrow-list al1 al2 r)
      (: (arrow ...) (arrow ...) report -> report)
      (match r
        [{'fail il} {'fail il}]
        [{'success e}
         (if (eq? al1 {})
           r
           (unify/arrow-list
            (cdr al1) (cdr al2)
            (unify/arrow (car al1) (car al2) e)))]))
    #+end_src

*** unify/trunk

    - it will not diverge on recursive call here
      because the trunk of recursive call
      only have name in it
      but not have the arrow-list

    - thus
      to be able to unify on trunk
      is different from
      to be able to unify on arrow or lambda
      we do not really have
      second order semantic unification here

    #+begin_src scheme
    (define (unify/trunk t1 t2 e)
      (: trunk trunk env -> report)
      (match {t1 t2}
        [{{a1 al1 dl1 i1} {a2 al2 dl2 i2}}
         (if (not (eq? i1 i2))
           ;; syntactic unification fail
           ;; recur to unify/data
           ;; only when at least one of the trunk is reducible
           ;; and if the arguments of this recur are both trunk
           ;; they must be non-reducible
           ;; thus will not get in to this branch again
           (match {(filter-arrow-list al1 dl1 e)
                   (filter-arrow-list al2 dl2 e)}
             [{l1 l2}
              (if (not (or (eq? 1 (length l1)) (eq? 1 (length l2))))
                {'fail {`(unify/trunk
                          fail indexes are different
                          (trunk1: ,t1)
                          (trunk2: ,t2)
                          and both trunks are non-reducible)}}
                (match {(compute/trunk t1 e)
                        (compute/trunk t2 e)}
                  [{{'success {(d1 . __) __ __}}
                    {'success {(d2 . __) __ __}}}
                   (unify/data d1 d2 e)]
                  [{__ __}
                   {'fail {`(unify/trunk
                             fail indexes are different
                             (trunk1: ,t1)
                             (trunk2: ,t2)
                             and fail to compute/trunk one of them)}}]))])
           (cond [(and (symbol? al1)
                       (symbol? al2)
                       (eq? al1 al2))
                  (unify/data-list
                   dl1 dl2
                   (unify/arrow a1 a2 e))]
                 [(and (symbol? al1)
                       (not (symbol? al2)))
                  (unify/trunk (trunk->trunk* t1 e) t2 e)]
                 [(and (not (symbol? al1))
                       (symbol? al2))
                  (unify/trunk  t1 (trunk->trunk* t2 e) e)]
                 [else ;; al1 al2 are both not symbol
                  (match (unify/data-list
                          dl1 dl2
                          (unify/lambda {a1 al1} {a2 al2} e))
                    [{'success e1} {'success e1}]
                    [{'fail il}
                     ;; recur to unify/data
                     ;; only when at least one of the trunk is reducible
                     ;; and if the arguments of this recur are both trunk
                     ;; they must be non-reducible
                     ;; thus will not get in to this branch again
                     (match {(filter-arrow-list al1 dl1 e)
                             (filter-arrow-list al2 dl2 e)}
                       [{l1 l2}
                        (if (not (or (eq? 1 (length l1)) (eq? 1 (length l2))))
                          {'fail {`(unify/trunk
                                    syntacticly different trunks
                                    (trunk1: ,t1)
                                    (trunk2: ,t2)
                                    and both trunks are non-reducible)}}
                          (match {(compute/trunk t1 e)
                                  (compute/trunk t2 e)}
                            [{{'success {(d1 . __) __ __}}
                              {'success {(d2 . __) __ __}}}
                             (unify/data d1 d2 e)]
                            [{__ __}
                             {'fail {`(unify/trunk
                                       fail indexes are different
                                       (trunk1: ,t1)
                                       (trunk2: ,t2)
                                       and fail to compute/trunk one of them)}}]))])])]))]))
    #+end_src

*** unify/trunk/data

    #+begin_src scheme
    (define (unify/trunk/data t d e)
      (: trunk data env -> report)
      (match (compute/trunk t e)
        [{'fail il}
         {'fail (cons `(unify/trunk/data
                        (trunk: ,t)
                        (data: ,d))
                      il)}]
        [{'success e1}
         (match (env/pop e1)
           [{{'trunk t1} e2}
            {'fail {`(unify/trunk/data
                      (trunk: ,t)
                      compute to
                      (trunk: ,t1))}}]
           [{d1 e2}
            (unify/data d1 d e2)])]))
    #+end_src

* eva

*** note

  - the design must be separately testable
    first without check
    then add check

*** check+ & check- & ?check

    #+begin_src scheme
    (define check? #t)
    (define (check+) (set! check? #t) #t)
    (define (check-) (set! check? #f) #f)
    #+end_src

*** init-env

    #+begin_src scheme
    (define init-env
      '(()
        ()
        ((type . (cons/type ((()
                              (cons (type ())))
                             type
                             type))))))
    #+end_src

*** eva

    #+begin_src scheme
    (define-syntax eva
      (syntax-rules ()
        [(eva e ...)
         (eva/top-list (map parse/top (quote (e ...))) init-env)]))
    #+end_src

*** eva/top-list

    #+begin_src scheme
    (define (eva/top-list tl e)
      (: (top ...) env -> env)
      (match tl
        [{} e]
        [(t . r) (eva/top-list r (eva/top t e))]))
    #+end_src

*** parse/top

    #+begin_src scheme
    (define (parse/top s)
      (: sexp-top -> top)
      (match s
        [('deftype n a . body)
         {'deftype {{n a} (parse/top/deftype-body body)}}]
        [('defn n a . al)
         {'defn {{n a} al}}]
        [{'app a}
         {'app a}]))
    #+end_src

*** parse/top/deftype-body

    #+begin_src scheme
    (define (parse/top/deftype-body body)
      (: deftype-body -> ((form1/name form1/arrow) ...))
      (cond [(eq? '() body) '()]
            [(eq? '() (cdr body))
             (orz 'parse/top/deftype-body ("wrong body : ~a~%" body))]
            [else
             (cons (list (car body) (cadr body))
                   (parse/top/deftype-body (cddr body)))]))
    #+end_src

*** eva/top

    #+begin_src scheme
    (define (eva/top t e)
      (: top env -> env)
      (match t
        [{'deftype deftype} (eva/deftype deftype e)]
        [{'defn defn} (eva/defn defn e)]
        [{'app a} (eva/app a e)]))
    #+end_src

*** form1/arrow->arrow

    #+begin_src scheme
    (define (form1/arrow->arrow a e)
      (: form1/arrow env -> arrow)
      (match (pass2/arrow (pass1/arrow 0 a) {})
        [{a1 s} (pass3/get-arrow a1 e)]))
    #+end_src

*** eva/deftype

    #+begin_src scheme
    (define (eva/deftype deftype e)
      (: ((form1/name form1/arrow) ((form1/name form1/arrow) ...)) env -> env)
      (match e
        [{ds bs ns}
         (match deftype
           [{{n a} nal}
            (let* ([nl (map car nal)]
                   [a0 (form1/arrow->arrow a e)]
                   [ns1 (cons (cons n
                                    {'cons/type {a0 n nl}})
                              ns)])
              (eva/deftype/data-constructor-list n nal {ds bs ns1}))])]))

    (define (eva/deftype/data-constructor type-name na e)
      (: name (form1/name form1/arrow) env -> env)
      (match e
        [{ds bs ns}
         (match na
           [{n a}
            (let ([a0 (form1/arrow->arrow a e)])
              {ds
               bs
               (cons (cons n {'cons/data {a0 n type-name}})
                     ns)})])]))

    (define (eva/deftype/data-constructor-list type-name nal e)
      (: name ((form1/name form1/arrow) ...) env -> env)
      (match nal
        [{} e]
        [(na . r)
         (eva/deftype/data-constructor-list
          type-name r
          (eva/deftype/data-constructor type-name na e))]))
    #+end_src

*** eva/defn

    #+begin_src scheme
    (define (eva/defn defn e)
      (: ((form1/name form1/arrow) (form1/arrow ...)) env -> env)
      (match e
        [{ds bs ns}
         (match defn
           [{{n a} al}
            (let* ([a0 (form1/arrow->arrow a e)]
                   ;; need to put the type into ns first
                   ;; for recursive call in arrow-list
                   ;; that is
                   ;; in ns
                   ;; type global-bindings and arrow-list global-bindings
                   ;; must be separately interfaced
                   [ns0 (cons (cons n {'lambda {a0 'placeholder}})
                              ns)]
                   [al0 (map (lambda (x)
                               (form1/arrow->arrow x {ds bs ns0}))
                          al)]
                   [ns1 (cons (cons n
                                    {'lambda {a0 al0}})
                              ns)])
              (if (not check?)
                {ds bs ns1}
                (match (check a0 al0 {ds bs ns1})
                  ;; note that the bs of the env
                  ;; returned by check is not clean
                  ;; thus e1 is not used as return env
                  [{'success e1} {ds bs ns1}]
                  [{'fail il}
                   (cat ("eva/defn fail to define : ~a~%" defn))
                   (pretty-print il)
                   (orz 'eva/defn ("end of report~%"))])))])]))
    #+end_src

*** eva/app

    #+begin_src scheme
    (define (eva/app a e)
      (: form1/arrow env -> env)
      (let ([a0 (form1/arrow->arrow a e)])
        (match (compute/arrow a0 e)
          [{'success e1} e1]
          [{'fail il}
           (cat ("eva/ap fail~%"))
           (pretty-print il)
           (cat ("~%"))
           (orz 'eva/ap ("end of report~%"))])))
    #+end_src

* sequent

*** sequent

    #+begin_src scheme
    (define (sequent)
      (: -> [loop])
      (cat ("welcome to sequent ^-^/~%"))
      (sequent/repl init-env))
    #+end_src

*** >< sequent/repl

    #+begin_src scheme
    (define (sequent/repl e)
      (: env -> [loop])
      (let* ([top (read)]
             [e1 (eva/top (parse/top top) e)])
        (match e1
          [{ds1 bs1 ns1}
           (print/data-list ds1 e1)
           (newline)
           (sequent/repl e1)])))
    #+end_src

* check

*** check

    #+begin_src scheme
    (define (check t al e)
      (: arrow (arrow ...) env -> report)
      (match al
        [{} {'success e}]
        [(a . r)
         (match (check/arrow t a e)
           [{'success e1}
            ;; note that the above return env is droped
            ;; this is viewed as undo
            (check t r e)]
           [{'fail il} {'fail il}])]))
    #+end_src

*** check/arrow

    - ><><>< how to refactor this

    #+begin_src scheme
    (define (check/arrow t a e)
      (: arrow arrow env -> report)
      (match (list t a)
        [{{tac tsc} {ac sc}}
         (let ([alen (length ac)]
               [talen (length tac)]
               [slen (length sc)]
               [tslen (length tsc)])
           (match (compute/cedent tac e)
             [{'fail il}
              {'fail (cons `(check/arrow
                             fail on compute/cedent
                             (type-antecedent: ,tac))
                           il)}]
             [{'success e1}
              (match (type-compute/cedent ac e1)
                [{'fail il}
                 {'fail (cons `(check/arrow
                                fail on compute/cedent
                                (antecedent: ,ac))
                              il)}]
                [{'success e2}
                 (match e2
                   [{ds2 bs2 ns2}
                    (match (unify/data-list
                            (take ds2 talen)
                            (take (drop ds2 talen) alen)
                            {'success {(drop (drop ds2 talen) alen)
                                       bs2
                                       ns2}})
                      [{'fail il}
                       {'fail (cons `(check/arrow
                                      fail on unify/data-list
                                      (type-antecedent: ,tac)
                                      (antecedent: ,ac))
                                    il)}]
                      [{'success e3}
                       (match (compute/cedent tsc e3)
                         [{'fail il}
                          {'fail (cons `(check/arrow
                                         fail on compute/cedent
                                         (type-succedent: ,tsc))
                                       il)}]
                         [{'success e4}
                          (match (type-compute/cedent sc e4)
                            [{'fail il}
                             {'fail (cons `(check/arrow
                                            fail on
                                            (succedent: ,sc))
                                          il)}]
                            [{'success e5}
                             (match e5
                               [(ds5 bs5 ns5)
                                (unify/data-list
                                 (take ds5 tslen)
                                 (take (drop ds5 tslen) slen)
                                 {'success {(drop (drop ds5 tslen) slen)
                                            bs5
                                            ns5}})])])])])])])]))]))
    #+end_src

* type-compute

*** type-compute/cedent

    #+begin_src scheme
    (define (type-compute/cedent c e)
      (: cedent env -> report)
      (match c
        [{} {'success e}]
        [(d . r)
         (match (type-compute d e)
           [{'fail il} {'fail il}]
           [{'success e1}
            (type-compute/cedent r e1)])]))
    #+end_src

*** type-compute

    #+begin_src scheme
    (define (type-compute d e)
      (: data env -> report)
      (match d
        [{'var x} (type-compute/var x e)]
        [{'cons x} (type-compute/cons x e)]
        [{'arrow x} (type-compute/arrow x e)]
        [{'lambda x} (type-compute/lambda x e)]
        [{'trunk x} (type-compute/trunk x e)]))
    #+end_src

*** type-compute/var

    #+begin_src scheme
    (define (type-compute/var v e)
      (: var env -> report)
      (match v
        [{id level}
         (compute/var {id (+ 1 level)} e)]))
    #+end_src

*** type-compute/cons

    #+begin_src scheme
    (define (type-compute/cons c e)
      (: cons env -> report)
      (match e
        [{ds bs ns}
         (match c
           [{n dl}
            (let ([found (assq n ns)])
              (if (not found)
                (orz 'type-compute/cons
                  ("unknow name : ~a~%" n)
                  ("cons : ~a~%" c))
                (let ([meaning (cdr found)])
                  (match meaning
                    [{any-type (t . __)}
                     (match (type-compute/cedent (reverse dl) e)
                       [{'fail il} {'fail il}]
                       [{'success e1}
                        (compute/arrow (copy-arrow t) e1)])]))))])]))
    #+end_src

*** type-compute/arrow

    #+begin_src scheme
    (define (type-compute/arrow a e)
      (: arrow env -> report)
      (match e
        [{ds bs ns}
         (match (copy-arrow a)
           ;; need to copy the arrow first
           ;; because the return arrow might be applied somewhere else
           [{ac sc}
            (match (type-compute/cedent ac {{} (cons '(commit-point) bs) ns})
              [{'fail il} {'fail il}]
              [{'success {ds1 bs1 ns1}}
               (match (type-compute/cedent sc {{} bs1 ns1})
                 [{'fail il} {'fail il}]
                 [{'success {ds2 bs2 ns2}}
                  {'success {(cons {'arrow {(reverse ds1) (reverse ds2)}}
                                   ds)
                             (bs/commit! bs2)
                             ns2}}])])])]))
    #+end_src

*** type-compute/lambda

    #+begin_src scheme
    (define (type-compute/lambda l e)
      (: lambda env -> report)
      (match e
        [{ds bs ns}
         (match l
           [{a al}
            {'success {(cons {'arrow a} ds)
                       bs
                       ns}}])]))
    #+end_src

*** type-compute/trunk

    #+begin_src scheme
    (define (type-compute/trunk t e)
      (: trunk env -> report)
      (match e
        [{ds bs ns}
         (match t
           [{a __ dl i}
            (match (type-compute/cedent (reverse dl) {{} bs ns})
              [{'fail il} {'fail il}]
              [{'success e1}
               (match e1
                 [{ds1 bs1 ns1}
                  (match (compute/arrow (copy-arrow a) e1)
                    [{'fail il} {'fail il}]
                    [{'success e2}
                     {'success {(cons (proj i e2) ds)
                                bs1
                                ns1}}])])])])]))
    #+end_src

* infer

*** infer/arrow

    #+begin_src scheme
    (define (infer/arrow a e)
      (: arrow env -> arrow)
      (match (type-compute/arrow a e)
        [{'fail il}
         (orz 'infer/arrow
           ("fail to type-compute/arrow : ~a~%" a)
           ("reported info-list : ~a~%" il))]
        [{'success {(a1 . __) __ __}}
         a1]))
    #+end_src

*** infer/arrow-list

    #+begin_src scheme
    (define (infer/arrow-list al e)
      (: (arrow ...) env -> arrow)
      (unite/arrow-list
       (map (lambda (x) (infer/arrow x e)) al)
       e))
    #+end_src

*** unite/arrow-list

    #+begin_src scheme
    (define (unite/arrow-list al e)
      (: (arrow ...) env -> arrow)
      (letrec ([recur
                (lambda (a l)
                  (: arrow (arrow ...) -> arrow)
                  (match l
                    [{} a]
                    [(h . r)
                     (recur (unite/two a h e) r)]))])
        (recur (car al) (cdr al))))
    #+end_src

*** unite/two

    - this is the meet operation of the subsumption lattice of arrow

    #+begin_src scheme
    (define (unite/two a1 a2 e)
      (: arrow arrow env -> arrow)
      (match e
        [{ds bs ns}
         (match {a1 a2}
           [{{ac1 sc1} {ac2 sc2}}
            (let ([ac1 (copy-arrow ac1)]
                  [sc1 (copy-arrow sc1)]
                  [ac2 (copy-arrow ac2)]
                  [sc2 (copy-arrow sc2)])
              (match (unify/data-list
                      ac1 ac2
                      {'success {{} (cons '(commit-point) bs) ns}})
                [{'fail il} (orz 'unite/two
                              ("fail to unify antecedent~%")
                              ("ac1 : ~a~%" ac1)
                              ("ac2 : ~a~%" ac2))]
                [{'success {__ bs1 ns1}}
                 (match (unify/data-list
                         sc1 sc2
                         {'success {{} bs1 ns1}})
                   [{'fail il} (orz 'unite/two
                                 ("fail to unify succedent~%")
                                 ("sc1 : ~a~%" sc1)
                                 ("sc2 : ~a~%" sc2))]
                   [{'success {ds2 bs2 ns2}}
                    (bs/commit! bs2)
                    {ac1 sc1}])]))])]))
    #+end_src
