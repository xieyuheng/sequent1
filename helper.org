#+PROPERTY: tangle helper.scm

* cat & orz

  #+begin_src scheme
  (define-syntax cating
    (syntax-rules ()
      [(cating (str . args))
      (format #f str . args)]
      [(cat (str . args) (str2 . args2) ...)
       (string-append
        (cating (str . args))
        (cating (str2 . args2) ...))]))

  (define-syntax cat
    (syntax-rules ()
      [(cat e ...)
       (format #t (cating e ...))]))

  (define-syntax orz
    (syntax-rules ()
      [(orz who c ...)
       (error who (cating ("~%") c ...))]))
  #+end_src

* type & :

  #+begin_src scheme
  (define-syntax type
    (syntax-rules ()
      [(type . body)
       (void)]))

  (define-syntax :
    (syntax-rules ()
      [(: . body)
       (void)]))
  #+end_src

* little-tester

  #+begin_src scheme
  (define-syntax test
    (syntax-rules ()
      [(test b1 b2)
       (if (equal? b1 b2)
         #t
         (let ()
           (cat ("~%")
                ("<begin-test-fail-report>~%")
                (":actual-form:~%"))
           (pretty-print (quote b1))
           (cat (":actual-value:~%"))
           (pretty-print b1)
           (cat (":expect-form:~%"))
           (pretty-print (quote b2))
           (cat (":expect-value:~%"))
           (pretty-print b2)
           (cat ("<test-fail-report-end>~%"))
           (orz 'test (">_<"))))]))
  #+end_src

* list

*** take & drop

    #+begin_src scheme
    (define (take lis k)
      (let recur ((lis lis) (k k))
        (if (zero? k) '()
            (cons (car lis)
                  (recur (cdr lis) (- k 1))))))

    (define (drop lis k)
      (let iter ((lis lis) (k k))
        (if (zero? k) lis (iter (cdr lis) (- k 1)))))
    #+end_src

*** left-of & right-of

    #+begin_src scheme
    (define (left-of s l)
      (: sexp list -> list)
      (cond [(equal? s (car l)) '()]
            [else (cons (car l) (left-of s (cdr l)))]))

    (define (right-of s l)
      (: sexp list -> list)
      (cond [(equal? s (car l)) (cdr l)]
            [else (right-of s (cdr l))]))
    #+end_src

*** sublist

    #+begin_src scheme
    (define (sublist l start end)
      (: list index index -> list)
      (cond [(and (eq? 0 start) (<= end 0)) '()]
            [(and (not (eq? 0 start)))
             (sublist (cdr l) (- start 1) (- end 1))]
            [(and (eq? 0 start) (not (eq? 0 end)))
             (cons (car l) (sublist (cdr l) 0 (- end 1)))]))
    #+end_src

*** genlist

    #+begin_src scheme
    (define (genlist len)
      (: length -> list)
      (letrec ([recur
                (lambda (len counter)
                  (cond [(eq? len counter) '()]
                        [else (cons counter
                                    (recur len (+ 1 counter)))]))])
        (recur len 0)))
    #+end_src

*** substitute

    #+begin_src scheme
    (define (substitute e p? l)
      (: element (element -> bool) (element ...) -> (element ...))
      (cond [(eq? '() l) '()]
            [(p? (car l)) (cons e (cdr l))]
            [else (cons (car l) (substitute e p? (cdr l)))]))
    #+end_src

*** list-every? & list-any?

    #+begin_src scheme
    (define (list-every? p? l)
      (: (element -> bool) l -> bool)
      (not (member #f (map p? l))))

    (define (list-any? p? l)
      (: (element -> bool) l -> bool)
      (member #t (map p? l)))
    #+end_src

* sexp

  #+begin_src scheme
  (define (sexp->string s)
    (format #f "~a" s))
  #+end_src

* string

  #+begin_src scheme
  (define (find-char c s)
    (: char string -> (or curser #f))
    (find-char/curser c s 0))

  (define (find-char/curser c s curser)
    (: char string curser -> (or curser #f))
    (if (>= curser (string-length s))
      #f
      (let ([c0 (substring s curser (+ 1 curser))])
        (if (equal? c c0)
          curser
          (find-char/curser c s (+ 1 curser))))))
  #+end_src

* symbol

  #+begin_src scheme
  (define (symbol-append . l)
    (: symbol ... -> symbol)
    (string->symbol
     (apply string-append
       (map symbol->string l))))
  #+end_src

* monad

*** with-monad

    #+begin_src scheme
    (define-macro (with-monad m body)
      `(let ([mbind (monad->mbind ,m)]
             [return (monad->return ,m)])
         ,body))
    #+end_src

*** test

    #+begin_src scheme :tangle no
    (define monad->mbind car)
    (define monad->return cadr)

    (define identity-m
      (list
       (lambda (value function)
         (function value))
       (lambda (value)
         value)))

    (define maybe-m
      (list
       (lambda (value function)
         (if (eq? value #f)
           #f
           (function value)))
       (lambda (value)
         (if (eq? value #f)
           #f
           value))))

    ;; (do/monad identity-m
    ;;   a <- 2
    ;;   b <- (+ 1 a)
    ;;   (return (* a b)))
    (with-monad
     identity-m
     (mbind 2
            (lambda (a)
              (mbind (+ 1 a)
                     (lambda (b)
                       (return
                         (* a b)))))))

    ;; (do/monad maybe-m
    ;;   a <- 2
    ;;   b <- (+ 1 a)
    ;;   (display "<here> ")
    ;;   (return (* a b)))
    (with-monad
     maybe-m
     (mbind 2
            (lambda (a)
              (mbind (+ 1 a)
                     (lambda (b)
                       (display "<here> ")
                       (return
                         (* a b)))))))

    ;; (do/monad maybe-m
    ;;   a <- #f
    ;;   b <- (+ 1 a)
    ;;   (display "<here> ")
    ;;   (return (* a b)))
    (with-monad
     maybe-m
     (mbind #f
            (lambda (a)
              (mbind (+ 1 a)
                     (lambda (b)
                       (display "<here> ")
                       (return
                         (* a b)))))))
    #+end_src

*** monad/pass1 & monad/pass2

    #+begin_src scheme
    (define (monad/pass1 body)
      (: '(a <- 2
           b <- (+ 1 a)
           (return (* a b)))
         ----------------->
         '((back-arrow a 2)
           (back-arrow b (+ 1 a))
           (non-arrow (return (* a b)))))
      (match body
        [(v '<- e) (cons {'non-arrow e} '())]
        [(v '<- e . r) (cons {'back-arrow v e} (monad/pass1 r))]
        [(e) (cons {'non-arrow e} '())]
        [(e . r) (cons {'non-arrow e} (monad/pass1 r))]))

    ;; (monad/pass1 '(a <- 2
    ;;                b <- (+ 1 a)
    ;;                (return (* a b))))

    (define (monad/pass2 body)
      (: '((back-arrow a 2)
           (back-arrow b (+ 1 a))
           (non-arrow (return (* a b))))
         ----------------->
         ((mbind
           2 (lambda (a)
               (mbind
                (+ 1 a) (lambda (b)
                          (return (* a b))))))))
      (match body
        [({'non-arrow e}) e]
        [({'non-arrow e} . r) `(begin
                                 ,e ,(monad/pass2 r))]
        ;; [({'back-arrow v e}) e]
        [({'back-arrow v e} . r) `(mbind
                                   ,e (lambda (,v)
                                        ,(monad/pass2 r)))]))

    ;; (monad/pass2 '((back-arrow a 2)
    ;;                (back-arrow b (+ 1 a))
    ;;                (non-arrow (return (* a b)))))
    #+end_src

*** monad

    #+begin_src scheme
    (define-macro (do/monad m . body)
      `(with-monad ,m ,(monad/pass2 (monad/pass1 body))))
    #+end_src

*** test

    #+begin_src scheme :tangle no
    (define monad->mbind car)
    (define monad->return cadr)

    (define identity-m
      (list
       (lambda (value function)
         (function value))
       (lambda (value)
         value)))

    (define maybe-m
      (list
       (lambda (value function)
         (if (eq? value #f)
           #f
           (function value)))
       (lambda (value)
         (if (eq? value #f)
           #f
           value))))

    (do/monad identity-m
      a <- 2
      b <- (+ 1 a)
      (return (* a b)))

    (do/monad maybe-m
      a <- 2
      b <- (+ 1 a)
      (display "<here> ")
      (return (* a b)))

    (do/monad maybe-m
      a <- #f
      b <- (+ 1 a)
      (display "<here> ")
      (return (* a b)))
    #+end_src

*** define-monad & monad->mbind & monad->return

    #+begin_src scheme
    (define-macro (define-monad name . body)
      (let ([found/mbind (assq 'mbind body)])
        (if (not found/mbind)
          (orz 'define-macro
            ("fail to find mbind in body :~%")
            ("~a" body))
          (let ([found/return (assq 'return body)])
            (if (not found/return)
              (orz 'define-macro
                ("fail to find return in body :~%")
                ("~a" body))
              `(define ,name (list ,(cadr found/mbind)
                                   ,(cadr found/return))))))))

    (define monad->mbind car)
    (define monad->return cadr)
    #+end_src

*** test

    #+begin_src scheme :tangle no
    (define-monad identity-m
      [mbind
       (lambda (v f)
         (: value (value -> value) -> value)
         (f v))]
      [return
        (lambda (v)
          (: value -> value)
          v)])

    (do/monad identity-m
      a <- 2
      b <- (+ 1 a)
      (return (* a b)))


    (define-monad maybe-m
      [mbind
       (lambda (v f)
         (: (or value #f) (value -> (or value #f)) -> (or value #f))
         (if (eq? v #f)
           #f
           (f v)))]
      [return
        (lambda (v)
          (: value -> (or value #f))
          v)])

    (do/monad maybe-m
      a <- 2
      b <- (+ 1 a)
      ;; we do not have type check
      ;; so, anything can occors in do/monad
      (display "<here> ")
      (return (* a b)))

    (do/monad maybe-m
      a <- #f
      b <- (+ 1 a)
      (display "<here> ")
      (return (* a b)))


    (define-monad list-m
      [mbind
       (lambda (vl f)
         (: (value ...) (value -> (value ...)) -> (value ...))
         (apply append (map f vl)))]
      [return
        (lambda (v)
          (: value -> (value ...))
          (list v))])

    (do/monad list-m
      a <- (genlist 3)
      b <- (genlist 4)
      (return (* a b)))

    (do/monad list-m
      a <- (genlist 3)
      b <- (genlist 4)
      (return (list a b)))
    #+end_src
